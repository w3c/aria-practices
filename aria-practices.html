<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <title>WAI-ARIA Authoring Practices 1.1</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
  <script src="common/script/resolveReferences.js" class="remove"></script>
  <script src="common/biblio.js" class="remove"></script>
  <script src="respec-config.js" class="remove"></script>
  <link href="common/css/common.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <section id="abstract">
    <p>
      This document provides readers with an understanding of how to use <cite><a href="http://www.w3.org/TR/wai-aria-1.1/"><abbr title="Accessible Rich Internet Applications">WAI-ARIA</abbr> 1.1</a></cite> [[WAI-ARIA]] to create accessible rich internet applications.
      It describes considerations that might not be evident to most authors from the WAI-ARIA specification alone and recommends approaches to make widgets, navigation, and behaviors accessible using WAI-ARIA roles, states, and properties.
      This document is directed primarily to Web application developers, but the guidance is also useful for user agent and assistive technology developers.
    </p>

    <p>This document is part of the WAI-ARIA suite described in the <a href="http://www.w3.org/WAI/intro/aria.php">WAI-ARIA Overview</a>.</p>
  </section>

  <section id="sotd"></section>

  <section id="intro">
    <h2>Introduction</h2>

    <p>This section is <em>informative.</em></p>

    <p>
      The WAI-ARIA Authoring Practices Guide is intended to provide an understanding of how to use WAI-ARIA to create an accessible Rich Internet Application.
      It describes recommended WAI-ARIA usage patterns and provides an introduction to the concepts behind them.
    </p>

    <p>
      This guide is one part of a suite of resources that support the WAI-ARIA specification.
      The WAI-ARIA suite fills accessibility gaps identified by the [[WAI-ARIA-ROADMAP]].
    </p>

    <p>
      As explained in <a href="#ariaBackground">Background on WAI-ARIA</a>, languages used to create rich and dynamic web sites, e.g., HTML, Javascript, CSS, and SVG, do not natively include all the features required to make sites usable by people who use assistive technologies (AT) or who rely on keyboard navigation.
      The W3C Web Accessibility Initiative's (WAI) Accessible Rich Internet Applications working group (ARIA WG) is addressing these deficiencies through several W3C standards efforts, with a focus on the WAI-ARIA specifications.
      For an introduction to WAI-ARIA, see the <a href="http://www.w3.org/WAI/intro/aria.php">Accessible Rich Internet Applications Suite (WAI-ARIA) Overview</a>.
    </p>

    <p>
      With the understanding many prefer to learn from examples, the guide begins with a section that demonstrates how to make common widgets accessible with descriptions of expected behaviors supported by working code.
      Where it is helpful to do so, the examples refer to detailed explanations of supporting concepts in subsequent sections.
      The sections that follow the examples first provide background that helps build understanding of how WAI-ARIA works and how it fits into the larger web technology picture.
      Next, the guide covers general steps for building an accessible widget using WAI-ARIA, JavaScript, and CSS, including detailed guidance on how to make rich internet applications keyboard accessible.
      The scope then widens to include the full application, addressing the page layout and structural semantics critical to enabling a usable experience with assistive technologies on pages containing both rich applications and rich documents.
      It includes guidance on dynamic document management, use of WAI-ARIA Form properties, and the creation of WAI-ARIA-enabled alerts and dialogs.
    </p>
  </section>

  <section id="aria_ex">
    <h2>Design Patterns and Widgets</h2>

    <p>This section demonstrates how to make common rich internet application widgets and patterns accessible by applying WAI-ARIA roles, states, and properties and implementing keyboard support.</p>

    <p class="note">
      Although users of Mac OS X are familiar with using the <kbd>Command</kbd> key instead of the <kbd>Control</kbd> key, the <kbd>Command</kbd> key is typically reserved for desktop applications and OS-level integration.
      Until device and platform independence can be addressed in WAI-ARIA 2.0, the primary <kbd>Control</kbd> modifier key for WAI-ARIA widget interaction is specified as <kbd>Control</kbd> on all platforms, including Mac OS X.
    </p>

    <section id="aria_ex_widget">
      <h3>Generally Applicable Keyboard Recommendations </h3>

      <p>The following keyboard conventions are applicable to many of the patterns described in subsequent sections.</p>

      <ul>
        <li><kbd>Shift + F10</kbd> opens associated context menu</li>
        <li><kbd>Control + C</kbd> Copies to clipboard </li>
        <li><kbd>Control + V</kbd> Pastes from clipboard </li>
        <li><kbd>Control + X</kbd> Copies to clipboard and cuts </li>
        <li><kbd>Control + Z</kbd> undo last action</li>
        <li><kbd>Control + Y</kbd> Redo action</li>
      </ul>

      <p class="note">The following guidance on nested widgets will be moved to another section.</p>

      <p>
        <strong>Widgets within Widgets</strong>
        The general navigation model is for a user to tab to a widget, interact with the controls in that widget and then tab to move focus to the next widget in the tab order.
        By extension, when the construct of a widget contains another widget, tab will move focus to the contained widget because it is the next item in the tab order.
        This continues down the layers of widgets until the last widget is reached.
        For example, if there are two widgets A and B on a page where widget A contains within it Widget A1 and Widget A1 contains within it Widget A2, the focus sequence when pressing the tab key would be A, A1, A2, B.
      </p>
    </section>

    <section class="widget" id="accordion">
      <h3>Accordion (Sections With Show/Hide Functionality)</h3>

      <p>
        An accordion is a vertically stacked set of elements, such as labels or thumbnails, that allow the user to toggle the display of sections of content.
        Each labeling element can be expanded or collapsed to reveal or hide its associated content.
        Accordions are commonly used to reduce the need to scroll when presenting multiple sections of content on a single page.
      </p>

      <p>Terms for understanding accordions include:</p>

      <dl>
        <dt>Accordion Header:</dt>
        <dd>Label for or thumbnail representing a section of content that also serves as a control for showing, and in some implementations, hiding  the section of content. </dd>
        <dt>Accordion Panel:</dt>
        <dd>Section of content associated with an accordion header.</dd>
      </dl>

      <p>
        In some accordions, there are additional elements that are always visible adjacent to the accordion header.
        For instance, a menubutton may accompany each accordion header to provide access to actions that apply to that section.
        And, in some cases, a snippet of the hidden content may also be visually persistent.
      </p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>

        <ul>
          <li>
            <kbd>Enter</kbd> or <kbd>Space</kbd>:

            <ul>
              <li>
                When focus is on the accordion header for a collapsed panel, expands the associated panel.
                If the implementation allows only one panel to be expanded, and if another panel is expanded, collapses that panel.
              </li>

              <li>
                When focus is on the accordion header for an expanded panel, collapses the panel if the implementation supports collapsing.
                Some implementations require one panel to be expanded at all times and allow only one panel to be expanded; so, they do not support a collapse function.
              </li>
            </ul>
          </li>

          <li>
            <kbd>Down Arrow</kbd> (Optional): If focus is on an accordion header, moves focus to the next accordion header.
            If focus is on the last accordion header, either does nothing or moves focus to the first accordion header.
          </li>

          <li>
            <kbd>Up Arrow</kbd> (Optional): If focus is on an accordion header, moves focus to the previous accordion header.
            If focus is on the first accordion header, either does nothing or moves focus to the last accordion header.
          </li>

          <li>
            <kbd>Home</kbd> (Optional): When focus is on an accordion header, moves focus to the first accordion header.
          </li>

          <li>
            <kbd>End</kbd> (Optional): When focus is on an accordion header, moves focus to the last accordion header.
          </li>

          <li>
            <kbd>Control + Page Down</kbd> (Optional): If focus is inside an accordion
            panel or on an accordion header, moves focus to the next accordion header.
            If focus is in the last accordion header or panel, either does nothing or
            moves focus to the first accordion header.
          </li>

          <li>
            <kbd>Control + Page Up</kbd> (Optional): If focus is inside an accordion panel, moves focus to the header for that panel.
            If focus is on an accordion header, moves focus to the previous accordion header.
            If focus is on the first accordion header, either does nothing or moves focus to the last accordion header.
          </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties:</h4>

        <ul>
          <li>
            Each accordion header is contained in an element with role <a href="#button" class="role-reference">button</a>.
            The button label is the label for the associated accordion panel.
          </li>

          <li>
            Each accordion header <code>button</code> is wrapped in an element with role <a href="#heading" class="role-reference">heading</a> that has a value set for <a href="#aria-level" class="property-reference">aria-level</a> that is appropriate for the information architecture of the page.
            If the native host language has an element with an implicit <code>heading</code> and <code>aria-level</code>, such as an HTML heading tag, a native host language element may be used.
            The <code>button</code> element is the only element inside the <code>heading</code> element.
            That is, if there are other visually persistent elements, they are not included inside the <code>heading</code> element.
          </li>

          <li>
            If the accordion panel associated with an accordion header is visible, the header <code>button</code> element has <a href="#aria-expanded" class="state-reference">aria-expanded</a> set to <code>true</code>.
            If the panel is not visible, <a href="#aria-expanded" class="state-reference">aria-expanded</a> is set to <code>false</code>.
          </li>

          <li>
            The accordion header <code>button</code> element has <a href="aria-controls" class="property-reference">aria-controls</a> set to the ID of the element containing the accordion panel content.
          </li>

          <li>
            If the accordion panel associated with an accordion header is visible, and if the accordion does not permit the panel to be collapsed, the header <code>button</code> element has <a href="#aria-disabled" class="state-reference">aria-disabled</a> set to <code>true</code>.
          </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p><a href="examples/accordion/accordion1.html">Accordion Example</a>: demonstrates a form divided into three sections using an accordion to show one ssection at a time. </p>
      </section>
    </section>

    <section class="widget" id="alert">
      <h3>Alert</h3>

      <p>
        An <a class="role-reference" href="#alert">alert</a> is an element that displays a brief, important message in a way that attracts the user's attention without interrupting the user's task.
        Dynamically rendered alerts are automatically announced by most screen readers, and in some operating systems, they may trigger an alert sound.
        It is important to note that, at this time, screen readers do not inform users of alerts that are present on the page before page load completes.
      </p>
      <p>
        Because an alert is intended to provide important and potentially time-sensitive information without interfering with the user's ability to continue working, authors should ensure alerts do not affect the keyboard focus.
        If there is a need to interrupt work flow, consider using an <a href="#alertdialog">alert dialog</a>
      </p>
      <p>
        In most circumstances, authors should avoid making alerts disappear automatically.
        An alert that disappears too quickly can lead to failure to meet <a href="http://www.w3.org/TR/UNDERSTANDING-WCAG20/time-limits-no-exceptions.html">WCAG 2.0 success criterion 2.2.3</a>.
        In addition, authors should be careful to avoid overuse of alerts.
        Frequent interruptions inhibit usability for people with visual and cognitive disabilities, leading to failures to meet <a href="http://www.w3.org/TR/UNDERSTANDING-WCAG20/time-limits-postponed.html">WCAG 2.0 success criterion 2.2.4</a>.
      </p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <p>An alert (WAI-ARIA live region) does not require any keyboard interaction.</p>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <p>The widget has a role of <a class="role-reference" href="#alert">alert</a>.</p>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p><a href="examples/alert/index.html">Alert role example</a></p>
      </section>
    </section>

    <section class="widget" id="alertdialog">
      <h3>Alert and Message Dialogs</h3>
      <p class="note">This section is partially revised. Planned changes are being discussed in <a href="https://github.com/w3c/aria-practices/issues/54">issue 54</a>.</p>
      <p>
        An alert dialog  is a <a href="#dialog_modal">modal dialog</a> that interrupts the user's workflow to communicate an important message and acquire a response.
        Examples include action confirmation prompts and error message confirmations.
        The <a href="#alertdialog" class="role-reference">alertdialog</a> role enables assistive technologies and browsers to distinguish alert dialogs from other dialogs so they have the option of giving them special treatment, such as playing a system alert sound.
      </p>
      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <p>See the keyboard interaction section for the <a href="#dialog_modal">modal dialog pattern</a>.</p>
      </section>
            <section class="notoc">
                <h4>WAI-ARIA Roles, States, and Properties</h4>
                <ul>
                    <li>
                        The element that contains all elements of the dialog, including the alert
                        message and any dialog buttons, has role
                        <a class="role-reference" href="#alertdialog">alertdialog</a>.
                    </li>
                    <li>
                        The element with role <code>alertdialog</code> has either:
                        <ul>
                            <li>
                                A value for
                                <a href="#aria-labelledby" class="property-reference">aria-labelledby</a>
                                that refers to the element containing the title of the dialog if the
                                dialog has a visible title.
                            </li>
                            <li>
                                A value for
                                <a href="#aria-label" class="property-reference">aria-label</a>
                                if the dialog does not have a visible title.
                            </li>
                        </ul>
                    </li>
                    <li>
                        The element with role <code>alertdialog</code> has a value set for
                        <a href="#aria-describedby" class="property-reference">aria-describedby</a>
                        that refers to the element containing the alert message.
                    </li>
                </ul>
            </section>
            <section class="notoc">
        <h4>Example</h4>
        <p>
        Developing an example implementation of this pattern is <a href="https://github.com/w3c/aria-practices/issues/101">issue 101</a>.
        </p>
      </section>
    </section>

    <section class="widget" id="breadcrumb">
      <h3 class="widget-name">Breadcrumb</h3>

      <p>
        A breadcrumb consists of a list of links to the parent pages of the current page in hierarchical order.
        These help users find their place within a website or web application.
        Breadcrumbs are often placed horizontally before a page's main content.
      </p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>

        <p>Not applicable.</p>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>Breadcrumb trail is contained within a navigation landmark.</li>
          <li>The widget should be labelled programmatically via a heading or via either <a href="#aria-label" class="property-reference">aria-label</a> or <a href="#aria-labelledby" class="property-reference">aria-labelledby</a>.
          <li>
            The link to the current page has <a href="#aria-current" class="property-reference">aria-current</a> set to <code>page</code>.
            If the element representing the current page is not a link, aria-current is optional.
          </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>

        <ul>
          <li>
            <a href="examples/breadcrumb/index.html">Breadcrumb design pattern example</a>
          </li>
        </ul>
      </section>
    </section>

    <section class="widget" id="button">
      <h3>Button</h3>

      <p>
        A <a class="role-reference" href="#button">button</a> is a widget that enables users to trigger an action or event, such as submitting a form, opening a dialog, canceling an action, or performing a delete operation.
        A common convention for informing users that a button launches a dialog is to append &quot;&#8230;&quot; (ellipsis) to the button label, e.g., &quot;Save as&#8230;&quot;.
      </p>
      <p>In addition to the ordinary button widget, WAI-ARIA supports 2 other types of buttons:</p>
      <ul>
        <li>
          Toggle button: A two-state button that can be either off (not pressed) or on (pressed).
          To tell assistive technologies that a button is a toggle button, specify a value for the attribute <a href="#aria-pressed" class="state-reference">aria-pressed</a>.
          For example, a button labeled mute in an audio player could indicate that sound is muted by setting the pressed state true.
          <strong>Important:</strong> it is critical the label on a toggle does not change when its state changes.
          In this example, when the pressed state is true, the label should remain “Mute” so a screen reader will say something like “Mute toggle button pressed”. 
          Alternatively, if the design were to call for the button label to change from “Mute” to “Unmute,” the aria-pressed attribute would not be needed.
        </li>
        <li>Menu button: as described in the <a href="#menubutton">menu button pattern</a>, a button will be revealed to assistive technologies as a menu button if it has the property <a href="#aria-haspopup" class="property-reference">aria-haspopup</a> set true.</li>
      </ul>
      <p class="note">
        The types of actions performed by buttons are distinctly different from the function of a link (see <a href="#link">link pattern</a>).
        It is important that the role of a widget matches the function it provides.
        Ideally, the role of the element also matches its visual appearance.
        But, occasionally an element may be visually styled as an icon or link but perform the action of a button.
        In these cases, the element should be given a button role.
        Designers should work to avoid conflicts between visual appearance and WAI-ARIA semantics.
      </p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <p>
          With focus on the button, pressing the <kbd>Space</kbd> key or <kbd>Enter</kbd> key activates the button.
          Focus should behave appropriately for the type of action being performed.
          For example:
        </p>
        <ul>
          <li>
            If activating the button opens a dialog, the focus moves inside the dialog.
            (see <a href="#dialog_nonmodal">dialog pattern</a>)
          </li>
          <li>
            If activating the button closes a dialog, typically focus should return to the button that opened the dialog unless the function performed in the dialog context logically leads to a different element.
            For example, activating a cancel button in a dialog should always return focus to the button that opened the dialog.
            However, if the dialog is confirming a delete action that deletes the page from which it was opened, the focus must logically move to a new context.
          </li>
          <li>If activating the button does not dismiss the current context, then focus should typically remain on the button after activation, e.g., an Apply or Recalculate button.</li>
          <li>If the button action indicates a context change, such as move to next step in a wizard or add another search criteria, then it may be appropriate to move focus to the starting point for that action.</li>
          <li>
            If the button is activated with a shortcut key, the focus should usually remain in the context from which the shortcut key was activated.
            For example, if <kbd>Alt + U</kbd> were assigned to an &quot;Up&quot; button that moves the currently focused item in a list one position higher in the list, pressing <kbd>Alt + U</kbd> when the focus is in the list should not move the focus from the list.
          </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The button has role of <a class="role-reference" href="#button">button</a>.</li>
          <li>
            An accessible label is required.
            By default, the accessible name is computed from any text content inside the button element.
            However, it can also be provided with <a href="#aria-labelledby" class="property-reference">aria-labelledby"</a> or <a href="#aria-label" class="property-reference">aria-label</a>.
          </li>
          <li>If a description of the button's function is present, the button element has <a href="#aria-describedby" class="property-reference">aria-describedby</a> set to the ID of the element containing the description.</li>
          <li>When the action associated with a button is unavailable, the button displays in a <a class="state-reference" href="#aria-disabled">aria-disabled</a> state. </li>
          <li>
            If the button is a toggle button, it has an <a href="#aria-pressed" class="state-reference">aria-pressed</a> state.
            When the button is toggled, the value of this state is <code>true</code>, and when not toggled, the state is <code>false</code>.
          </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p><a href="examples/button/button.html">Button role examples</a></p>
      </section>
    </section>

    <section class="widget" id="checkbox">
      <h3>Checkbox</h3>

      <p>WAI-ARIA supports two types of <a href="#checkbox" class="role-reference">checkbox</a> widgets:</p>
      <ol>
        <li>Dual-state: The most common type of checkbox, it allows the user to toggle between two choices -- checked and not checked.</li>
        <li>Tri-state: This type of checkbox supports an additional third state known as partially checked.</li>
      </ol>
      <p>
        One common use of a tri-state checkbox can be found in software installers where a single tri-state checkbox is used to represent and control the state of an entire group of install options.
        And, each option in the group can be individually turned on or off with a dual state checkbox.
      </p>
      <ul>
        <li>If all options in the group are checked, the overall state is represented by the tri-state checkbox displaying as checked.</li>
        <li>If some of the options in the group are checked, the overall state is represented with the tri-state checkbox displaying as partially checked.</li>
        <li>If none of the options in the group are checked, the overall state of the group is represented with the tri-state checkbox displaying as not checked.</li>
      </ul>
      <p>The user can use the tri-state checkbox to change all options in the group with a single action:</p>
      <ul>
        <li>Checking the overall checkbox checks all options in the group.</li>
        <li>Unchecking the overall checkbox will uncheck all options in the group.</li>
        <li>
          And, In some implementations, the system may remember which options were checked the last time the overall status was partially checked.
          If this feature is provided, activating the overall checkbox a third time recreates that partially checked state where only some options in the group are checked.
        </li>
      </ul>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <p>When the checkbox has focus, pressing the <kbd>Space</kbd> key changes the state of the checkbox.</p>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The checkbox has role <a href="#checkbox" class="role-reference">checkbox</a>.</li>
          <li>The checkbox has an accessible label, preferably provided by a visible label associated using <a href="#aria-labelledby" class="property-reference" >aria-labelledby</a>.</li>
          <li>When checked, the checkbox element has the state <a href="#aria-checked" class="state-reference" >aria-checked</a>=&quot;true&quot;.</li>
          <li>When not checked, it has the state <a href="#aria-checked" class="state-reference" >aria-checked</a>=&quot;false&quot;.</li>
          <li>When partially checked, it has the state <a href="#aria-checked" class="state-reference" >aria-checked</a>=&quot;mixed&quot;.</li>
          <li>If a set of checkboxes is presented as a logical group with a visible label, the checkboxes are included in an element with role <a href="#group" class="role-reference" >group</a> that has the property <a href="#aria-labelledby" class="property-reference" >aria-labelledby</a> set to the ID of the element containing the label.</li>
          <li>If the presentation includes additional descriptive static text relevant to a checkbox or checkbox group, the checkbox or checkbox group has the property <a href="#aria-describedby" class="property-reference">aria-describedby</a> set to the ID of the element containing the description.</li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Examples</h4>
        <ul>
          <li>
            <a href="examples/checkbox/checkbox-1.html">Simple Two-State Checkbox Example</a>: Demonstrates a simple 2-state checkbox.
          </li>
          <li>
            <a href="examples/checkbox/checkbox-2.html">Tri-State Checkbox With Grouping Label Examples</a>:
            three example implementations that demonstrate how to make a widget that uses the <code>mixed</code> value for <code>aria-checked</code> and also show three different ways of labeling a collection of checkboxes so screen reader users can perceive that all members of the collection are part of a logical group.
          </li>
        </ul>
      </section>
    </section>

    <section class="widget" id="combobox">
      <h3>Combo Box</h3>
      <p>Drafting this section is <a href="https://github.com/w3c/aria-practices/issues/31">issue 31</a>. </p>
    </section>

    <section class="widget" id="dialog_modal">
      <h3>Dialog (Modal)</h3>

      <p class="note">This section is partially revised. Planned changes are being discussed in <a href="https://github.com/w3c/aria-practices/issues/42">issue 42</a>.</p>

      <p>
        A <a href="#dialog" class="role-reference">dialog</a> is a window overlayed on the primary window.
        A modal dialog is designed to interrupt the user to, for example, prompt the user to confirm an action or enter information, and it traps or contains keyboard focus until the dialog is closed.
        ARIA has a special role for modal dialogs that convey a brief, important message to the user -- the <a href="#alertdialog" class="role-reference">alertdialog</a> ( See the <a href="#alertdialog">Alert Dialog</a> design pattern).
      </p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>

        <ul>
          <li><kbd>Tab</kbd>: Moves focus to the next focusable element inside the dialog. Pressing tab with focus on the last focusable element in the dialog moves focus to the first focusable element in the dialog. </li>
          <li><kbd>Shift + Tab</kbd>: Moves focus to the previous focusable element inside the dialog. Pressing shift-tab with focus on the first focusable element in the dialog moves focus to the last focusable element in the dialog. </li>
          <li><kbd>Escape</kbd>: Closes the dialog without taking any action. </li>
          <li> <kbd>Enter</kbd>: Serves as the default submit action key if if the primary purpose of the dialog is to gather information </li>
        </ul>

        <ul class="note">
          <li>If the current focus item has <kbd>Escape</kbd> key behavior, the press of the <kbd>Escape</kbd> will be handled by the current item and the user may have to press <kbd>Escape</kbd> an additional time to close the dialog.</li>
          <li> When the dialog is closed or cancelled focus should return to the element in the application which had focus before the dialog is invoked. This is usually the control which opened the dialog. </li>
          <li> When a modal dialog opens focus goes to the first focusable item in the dialog. Determining the first focusable item must take into account elements which receive focus by default (form fields and links) as well as items which may have a tabindex attribute with a positive value. </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The element containing the dialog has a role of <a href="#dialog" class="role-reference">dialog</a>.</li>
          <li>The dialog box title is provided by either the <a href="#aria-label" class="property-reference">aria-label</a> or the <a href="#aria-labelledby" class="property-reference">aria-labelledby</a> property.</li>
          <li> The <a href="#aria-describedby" class="property-reference">aria-describedby</a> property may be set on the element with the <code>dialog</code> role to indicate which element or elements in the dialog contain content that describes the primary purpose or message of the dialog. Screen readers may automatically announce the specified description along with the dialog title and initially focused element when the dialog opens. </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p class="note">
          Any examples referenced here that are hosted outside www.w3.org may have changed and may not accurately exemplify the guidance in this section.
          The APG task force is developing examples for APG version 1.1 that will be directly incorporated into the guide.
        </p>
        <ul>
          <li><a href="http://developer.yahoo.com/yui/examples/container/container-ariaplugin_clean.html" rel="nofollow" target="_blank">YUI dialogs -- use first two dialog buttons</a></li>
          <li><a href="http://www.oaa-accessibility.org/examplep/alertdialog1/" target="_blank">Open Ajax Alliance (alertdialog)</a></li>
          <li><a href="http://archive.dojotoolkit.org/nightly/dojotoolkit/dijit/tests/test_Dialog.html" target="_blank">Dojo nightly</a></li>
        </ul>
      </section>
    </section>

    <section class="widget" id="dialog_nonmodal">
      <h3>Dialog (Non-Modal)</h3>
      <p>Drafting this section is <a href="https://github.com/w3c/aria-practices/issues/59">issue 59</a>. </p>
    </section>

    <section class="widget" id="grid">
      <h3>Grids : Interactive Tabular Data and Layout Containers</h3>

      <p>
        A <a href="#grid" class="role-reference">grid</a> widget is a container that enables users to navigate the information or interactive elements it contains using directional navigation keys, such as arrow keys, <kbd>Home</kbd> , and <kbd>End</kbd>.
        As a generic container widget that offers flexible keyboard navigation, it can serve a wide variety of needs.
        It can be used for purposes as simple as grouping a collection of checkboxes or navigation links or as complex as creating a full-featured spreadsheet application.
        While ARIA properties and assistive technologies use row and column nomenclature when describing and presenting the logical structure of elements with the <code>grid</code> role, using the <code>grid</code> role on an element does not necessarily imply that its visual presentation is tabular.
      </p>

      <p>When presenting content that is tabular, consider the following factors when choosing between implementing this <code>grid</code> patern or the <a href="#table">table</a> pattern.</p>

      <ul>
        <li>
          A <code>grid</code> is a composite widget so it:

          <ul>
            <li>Always contains multiple focusable elements. </li>
            <li>Has only one focusable element in the page tab sequence.</li>
            <li>Requires the author to provide code that <a href="#kbd_general_within">manages focus movement inside it</a>.</li>
          </ul>
        </li>

        <li>All focusable elements contained in a table are included in the page tab sequence. </li>
      </ul>

      <p>
        Uses of the <code>grid</code> pattern broadly fall into two categories: presenting tabular information (data grids) and grouping other widgets (layout grids).
        Even though both data grids and layout grids employ the same ARIA roles, states, and properties, differences in their content and purpose surface factors that are important to consider in keyboard interaction design.
        To address these factors, the following two sections describe separate keyboard interaction patterns for data and layout grids.
      </p>

      <section id="dataGrid" class="notoc">
        <h4>Data Grids For Presenting Tabular Information</h4>

        <p>
          A <code>grid</code> can be used to present tabular information that has column titles, row titles, or both.
          The <code>grid</code> pattern is particularly useful if the tabular information is editable or interactive.
          For example, when data elements are links to more information, rather than presenting them in a static table and including the links in the tab sequence, implementing the <code>grid</code> pattern provides users with intuitive and efficient keyboard navigation of the grid contents as well as a shorter tab sequence for the page.
          A <code>grid</code> may also offer functions, such as cell content editing, selection, cut, copy, and paste.
        </p>

        <p>
          In a grid that presents tabular data, every cell contains a focusable element or is itself focusable, regardless of whether the cell content is editable or interactive.
          There is one exception: if column or row header cells do not provide functions, such as sort or filter, they do not need to be focusable. One reason this is important is that screen readers need to be in their application reading mode, rather than their document reading mode, while the user is interacting with the grid.
          While in application reading mode, a screen reader user can only discover focusable elements and content that labels focusable elements.
          So, a screen reader user may unknowningly overlook elements contained in a grid that are either not focusable or not used to label a column or row.
          A more detailed description of this topic with examples is available in the section describing <a href="#ScreenReaderModes">screen reader document and application reading modes</a>.
        </p>

        <section class="notoc">
          <h5>Keyboard Interaction For Data Grids</h5>

          <p>
            The following keys provide grid navigation by moving focus among cells of the grid.
            These key commands are available by default after an element in the grid receives focus.
          </p>

          <ul>
            <li>
              <kbd>Right Arrow</kbd>: Moves focus one cell to the right.
              If focus is on the right-most cell in the row, focus does not move.
            </li>
            <li><kbd>Left Arrow</kbd>: Moves focus one cell to the left. If focus is on the left-most cell in the row, focus does not move.</li>
            <li><kbd>Down Arrow</kbd>: Moves focus one cell down. If focus is on the bottom cell in the column, focus does not move.</li>
            <li><kbd>Up Arrow</kbd>: Moves focus one cell Up. If focus is on the top cell in the column, focus does not move.</li>
            <li><kbd>Page Down</kbd>: Moves focus down an author-determined number of rows, typically scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows. If focus is in the last row of the grid, focus does not move.</li>
            <li><kbd>Page Up</kbd>: Moves focus up an author-determined number of rows, typically scrolling so the top row in the currently visible set of rows becomes one of the last visible rows. If focus is in the first row of the grid, focus does not move.</li>
            <li><kbd>Home</kbd>: moves focus to the first cell in the row that contains focus.</li>
            <li><kbd>End</kbd>: moves focus to the last cell in the row that contains focus.</li>
            <li><kbd>Control + Home</kbd>: moves focus to the first cell in the first row.</li>
            <li><kbd>Control + End</kbd>: moves focus to the last cell in the last row.</li>
          </ul>

          <ul class="note">
            <li>
              When the above grid navigation keys move focus, whether the focus is set on an element inside the cell or the grid cell depends on cell content.
              See <a href="gridNav_focus">Whether to Focus on a Cell or an Element Inside It</a>.
            </li>
            <li>
              While navigation keys, such as arrow keys, are moving focus from cell to cell, they are not available to do something like operate a combobox or move an editing caret inside of a cell.
              If this functionality is needed, see <a href="#gridNav_inside">Editing and Navigating Inside a Cell</a>.
            </li>
            <li>If navigation functions can dynamically add more rows or columns to the DOM, key events that move focus to the beginning or end of the grid, such as <kbd>control + End</kbd>, may move focus to the last row in the DOM rather than the last available row in the back-end data.</li>
          </ul>

          <p>If a grid supports selection of cells, rows, or columns, the following keys are commonly used for these functions.</p>

          <ul>
            <li><kbd>Control + Space</kbd>: selects the column that contains the focus.</li>
            <li><kbd>Shift + Space</kbd>: Selects the row that contains the focus. If the grid includes a column with checkboxes for selecting rows, this key can serve as a shortcut for checking the box when focus is not on the checkbox.</li>
            <li><kbd>Control + A</kbd>: Selects all cells.</li>
            <li><kbd>Shift + Right Arrow</kbd>: Extends selection one cell to the right.</li>
            <li><kbd>Shift + Left Arrow</kbd>: Extends selection one cell to the left.</li>
            <li><kbd>Shift + Down Arrow</kbd>: Extends selection one cell down.</li>
            <li><kbd>Shift + Up Arrow</kbd>: Extends selection one cell Up.</li>
          </ul>

          <p class="note">See <a href="#aria_ex_widget">Global Recommendations</a> for cut, copy and paste key assignments.</p>
        </section>
      </section>
      <section id="layoutGrid" class="notoc">
        <h4>Layout Grids for Grouping Widgets</h4>

        <p>
          The <code>grid</code> pattern  can be used to group a set of interactive elements, such as links, buttons,  or checkboxes.
          Since only one element in the entire grid is included in the tab sequence, grouping with a grid can dramatically reduce the number of tab stops on a page.
          This is especially valuable if scrolling through a list of elements dynamically loads more of those elements from a large data set, such as in a continuous list of suggested products on a shopping site.
          If elements in a list like this were in the tab sequence, keyboard users are effectively trapped in the list.
          If any elements in the group also have associated elements that appear on hover, the <code>grid</code> pattern is also useful for providing keyboard access to those contextual elements of the user interface.
        </p>

        <p>
          Unlike grids used to present data, A <code>grid</code> used for layout does not necessarily have header cells for labeling rows or columns and might contain only a single row or a single column.
          Even if it has multiple rows and columns, it may present a single, logically homogenous set of elements.
          For example, a list of recipients for a message may be a grid where each cell contains a link that represents a recipient.
          The grid may initially have a single row but then wrap into multiple rows as recipients are added.
          In such circumstances, grid navigation keys may also wrap so the user can read the list from beginning to end by pressing either <kbd>Right Arrow</kbd> or <kbd>Down Arrow</kbd>.
          While This type of focus movement wrapping can be very helpful in a layout grid, it would be disorienting if used in a data grid, especially for users of assistive technologies.
        </p>

        <p>
          Because arrow keys are used to move focus inside of a <code>grid</code>, a <code>grid</code> is both easier to build and use if the components it contains do not require the arrow keys to operate.
          If a cell contains an element like a <a href="#Listbox">listbox</a>, then an extra key command to focus and activate the listbox is needed as well as a command for restoring the grid navigation functionality.
          Aproaches to supporting this need are described in the section on <a href="#gridNav_inside">Editing and Navigating Inside a Cell</a>.
        </p>

        <section class="notoc">
          <h5>Keyboard Interaction For Layout Grids</h5>

          <p>
            The following keys provide grid navigation by moving focus among cells of the grid.
            These key commands are available by default after an element in the grid receives focus.
          </p>

          <ul>
            <li>
              <kbd>Right Arrow</kbd>: Moves focus one cell to the right.
              Optionally, if focus is on the right-most cell in the row, focus may move to the first cell in the following row.
              If focus is on the last cell in the grid, focus does not move.
            </li>
            <li>
              <kbd>Left Arrow</kbd>: Moves focus one cell to the left.
              Optionally, if focus is on the left-most cell in the row, focus may move to the last cell in the previous row.
              If focus is on the first cell in the grid, focus does not move.
            </li>
            <li>
              <kbd>Down Arrow</kbd>: Moves focus one cell down.
              Optionally, if focus is on the bottom cell in the column, focus may move to the top cell in the following column.
              If focus is on the last cell in the grid, focus does not move.
            </li>
            <li>
              <kbd>Up Arrow</kbd>: Moves focus one cell up.
              Optionally, if focus is on the top cell in the column, focus may move to the bottom cell in the previous column.
              If focus is on the first cell in the grid, focus does not move.
            </li>
            <li>
              <kbd>Page Down</kbd> (Optional): Moves focus down an author-determined number of rows, typically scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows.
              If focus is in the last row of the grid, focus does not move.
            </li>
            <li>
              <kbd>Page Up</kbd> (Optional): Moves focus up an author-determined number of rows, typically scrolling so the top row in the currently visible set of rows becomes one of the last visible rows.
              If focus is in the first row of the grid, focus does not move.
            </li>
            <li>
              <kbd>Home</kbd>: moves focus to the first cell in the row that contains focus.
              Optionally, if the grid has a single column or fewer than three cells per row, focus may instead move to the first cell in the grid.
            </li>
            <li>
              <kbd>End</kbd>: moves focus to the last cell in the row that contains focus.
              Optionally, if the grid has a single column or fewer than three cells per row, focus may instead move to the last cell in the grid.
            </li>
            <li><kbd>Control + Home</kbd> (optional): moves focus to the first cell in the first row.</li>
            <li><kbd>Control + End</kbd> (Optional): moves focus to the last cell in the last row.</li>
          </ul>
          <ul class="note">
            <li>
              When the above grid navigation keys move focus, whether the focus is sett on an element inside the cell or the grid cell depends on cell content.
              See <a href="gridNav_focus">Whether to Focus on a Cell or an Element Inside It</a>.
            </li>
            <li>
              While navigation keys, such as arrow keys, are moving focus from cell to cell, they are not available to do something like operate a combobox or move an editing caret inside of a cell.
              If this functionality is needed, see <a href="#gridNav_inside">Editing and Navigating Inside a Cell</a>.
            </li>
            <li>If navigation functions can dynamically add more rows or columns to the DOM, key events that move focus to the beginning or end of the grid, such as <kbd>control + End</kbd>, may move focus to the last row in the DOM rather than the last available row in the back-end data.</li>
          </ul>

          <p>It would be unusual for a layout grid to provide functions that require cell selection. If it did, though, the following keys are commonly used for these functions.</p>

          <ul>
            <li><kbd>Control + Space</kbd>: selects the column that contains the focus.</li>
            <li>
              <kbd>Shift + Space</kbd>: Selects the row that contains the focus.
              If the grid includes a column with checkboxes for selecting rows, this key can serve as a shortcut for checking the box when focus is not on the checkbox.
            </li>
            <li><kbd>Control + A</kbd>: Selects all cells.</li>
            <li><kbd>Shift + Right Arrow</kbd>: Extends selection one cell to the right.</li>
            <li><kbd>Shift + Left Arrow</kbd>: Extends selection one cell to the left.</li>
            <li><kbd>Shift + Down Arrow</kbd>: Extends selection one cell down.</li>
            <li><kbd>Shift + Up Arrow</kbd>: Extends selection one cell Up.</li>
          </ul>
          <p class="note">See <a href="#aria_ex_widget">Global Recommendations</a> for cut, copy and paste key assignments.</p>
        </section>
      </section>
      <section id="gridNav" class="notoc">
        <h4>Keyboard Interaction - Setting Focus and Navigating Inside Cells</h4>

        <p>This section describes two important aspects of keyboard interaction design shared by both data and layout grid patterns:</p>

        <ol>
          <li>Choosing whether a cell or an element inside a cell receives focus in response to grid navigation key events.</li>
          <li>Enabling grid navigation keys to be used to interact with elements inside of a cell.</li>
        </ol>

        <section id="gridNav_focus" class="notoc">
          <h5>Whether to Focus on a Cell Or an Element Inside IT</h5>

          <p>
            For assistive technology users, the quality of experience when navigating a grid heavily depends on both what a cell contains and on where keyboard focus is set.
            For example, if a cell contains a button and a grid navigation key places focus on the cell instead of the button, screen readers announce the button label but do not tell users a button is present.
          </p>

          <p>There are two optimal cell design and focus behavior combinations: </p>

          <ol>
            <li>
              A cell contains one widget whose operation does not require arrow keys and grid navigation keys set focus on that widget.
              Examples of such widgets include link, button, menubutton, toggle button, radio button (not radio group), switch, and checkbox.
            </li>
            <li>A cell contains text or a single graphic and grid navigation keys set focus on the cell.</li>
          </ol>

          <p>
            While any combination of widgets, text, and graphics may be included in a single cell, grids that do not follow one of these two cell design and focus movement patterns add complexity for authors or users or both.
            The reference implementations included in the example section below demonstrate some strategies for making other cell designs as accessible as possible, but the most widely accessible experiences are likely to come by applying the above two patterns.
          </p>
        </section>

        <section id="gridNav_inside" class="notoc">
          <h5>Editing and Navigating Inside a Cell</h5>

          <p>
            While navigation keys, such as arrow keys, are moving focus from cell to cell, they are not available to perform actions like operate a combobox or move an editing caret inside of a cell. The user may need keys that are used for grid navigation to operate
            elements inside a cell if a cell contains:
          </p>

          <ol>
            <li>Editable content.</li>
            <li>Multiple widgets.</li>
            <li>A widget that utilizes arrow keys in its interaction model, such as a radio group or slider.</li>
          </ol>

          <p>Following are common keyboard conventions for disabling and restoring grid navigation functions. </p>

          <ul>
            <li>
              <kbd>Enter</kbd>: Disables grid navigation and:
              <ul>
                <li>If the cell contains editable content, places focus in an input field, such as a <a href="#textbox" class="role-reference">textbox</a>. If the input is a single-line text field, a subsequent press of <kbd>Enter</kbd> may either restore grid navigation
                  functions or move focus to an input field in a neighboring cell.</li>
                <li>If the cell contains one or more widgets, places focus on the first widget. </li>
              </ul>
            </li>

            <li>
              <kbd>F2</kbd>:
              <ul>
                <li>If the cell contains editable content, places focus in an input field, such as a <a href="#textbox" class="role-reference">textbox</a>. A subsequent press of <kbd>F2</kbd> restores grid navigation functions. </li>
                <li>If the cell contains one or more widgets, places focus on the first widget. A subsequent press of <kbd>F2</kbd> restores grid navigation functions. </li>
              </ul>
            </li>

            <li>Alphanumeric keys: If the cell contains editable content, places focus in an input field, such as a <a href="#textbox" class="role-reference">textbox</a>. </li>
          </ul>

          <p>When grid navigation is disabled, conventional changes to navigation behaviors include: </p>

          <ul>
            <li><kbd>Escape</kbd>: restores grid navigation. If content was being edited, it may also undo edits.</li>
            <li>
              <kbd>Right Arrow</kbd> or <kbd>Down Arrow</kbd>: If the cell contains multiple widgets, moves focus to the next widget inside the cell, optionally wrapping to the first widget if focus is on the last widget.
              Otherwise, passes the key event to the focused widget.
            </li>
            <li>
              <kbd>Left Arrow</kbd> or <kbd>Up Arrow</kbd>: If the cell contains multiple widgets, moves focus to the previous widget inside the cell, optionally wrapping to the first widget if focus is on the last widget.
              Otherwise, passes the key event to the focused widget.
            </li>
            <li>
              <kbd>Tab</kbd>: moves focus to the next widget in the grid.
              Optionally, the focus movement may wrap inside a single cell or within the grid itself.
            </li>
            <li>
              <kbd>Shift + Tab</kbd>: moves focus to the previous widget in the grid.
              Optionally, the focus movement may wrap inside a single cell or within the grid itself.
            </li>
          </ul>
        </section>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The grid container has role <a href="#grid" class="role-reference">grid</a>. </li>
          <li>Each row container has role <a href="#row" class="role-reference">row</a> and is either a DOM descendant of or owned by the <code>grid</code> element or an element with role <a href="#rowgroup" class="role-reference">rowgroup</a>. </li>
          <li>Each cell is either a DOM descendant of or owned by a <code>row</code> element and has one of the following roles:
            <ul>
              <li><a href="#columnheader"  class="role-reference">columnheader</a> if the cell contains a title or header information for the column.</li>
              <li><a href="#rowheader"  class="role-reference">rowheader</a> if the cell contains title or header information for the row.</li>
              <li><a href="#gridcell" class="role-reference">gridcell</a> if the cell does not contain column or row header information.</li>
            </ul>
          </li>
          <li>
            If there is an element in the user interface that serves as a label for the grid, <a href="#aria-labelledby" class="property-reference">aria-labelledby</a> is set on the grid element with a value that refers to the labeling element.
            Otherwise, a label is specified for the grid element using <a href="#aria-label" class="property-reference">aria-label</a>.
          </li>
          <li>If the grid has a caption or description, <a href="#aria-describedby" class="property-reference">aria-describedby</a> is set on the grid element with a value refering to the element containing the description.</li>
          <li>If the grid provides sort functions, <a href="#aria-sort" class="property-reference">aria-sort</a> is set to an appropriate value on the header cell element for the sorted column or row as described in the section on <a href="#gridAndTableProperties">grid and table properties</a>. </li>
          <li>If the grid supports selection, when a cell or row is selected, the selected element has <a href="#aria-selected" class="state-reference">aria-selected</a> set <code>true</code>. </li>
          <li>
            If the grid provides content editing functionality and contains cells that may have edit capabilities disabled in certain conditions, <a href="#aria-readonly" class="state-reference">aria-readonly</a> may be set <code>true</code> on cells where editing is disabled.
            If edit functions are disabled for all cells, <code>aria-readonly</code> may be set <code>true</code> on the grid element.
            Grids that do not provide editing functions do not include the <code>aria-readonly</code> attribute on any of their elements.
          </li>
          <li>
            If there are conditions where some rows or columns are hidden or not present in the DOM, e.g., data is dynamically loaded when scrolling or the grid provides functions for hiding rows or columns, the following properties are applied as described in the section on <a href="#gridAndTableProperties">grid and table properties</a>.
            <ul>
              <li><a href="#aria-colcount" class="property-reference">aria-colcount</a> or <a href="#aria-rowcount" class="property-reference">aria-rowcount</a> is set to the total number of columns or rows, respectively. </li>
              <li><a href="#aria-colindex" class="property-reference">aria-colindex</a> or <a href="#aria-rowindex" class="property-reference">aria-rowindex</a> is set to the position of a cell within a row or column, respectively. </li>
            </ul>
          </li>
          <li>If the grid includes cells that span multiple rows or multiple columns, and if the <code>grid</code> role is NOT applied to an HTML <code>table</code> element, then <a href="#aria-rowspan" class="property-reference">aria-rowspan</a> or <a href="#aria-colspan" class="property-reference">aria-colspan</a> is applied as described in <a href="#gridAndTableProperties">grid and table properties</a>.</li>
        </ul>

        <ul class="note">
          <li>
            If the element with the <code>grid</code> role is an HTML <code>table</code> element, then it is not necessary to use ARIA roles for rows and cells because the HTML elements have implied ARIA semantics.
            For example, an HTML <code>&lt;TR&gt;</code> has an implied ARIA role of <code>row</code>.
            A <code>grid</code> built from an HTML <code>table</code> that includes cells that span multiple rows or columns must use HTML <code>rowspan</code> and <code>colspan</code> and must not use <code>aria-rowspan</code> or <code>aria-colspan</code>.
          </li>
          <li>
            If rows or cells are included in a grid via <a href="#aria-owns" class="property-reference">aria-owns</a>, they will be presented to assistive technologies after the DOM descendants of the <code>grid</code> element unless the DOM descendants are also included in the <code>aria-owns</code> attribute.
            See <a href="#relations_owns">using aria-owns</a> for a detailed explaination.
          </li>
        </ul>
      </section>

      <section class="notoc">
          <h4>Examples</h4>
          <ul>
            <li><a href="examples/grid/dataGrids.html">Data Grids</a>: Three example implementations of grid that include features relevant to presenting tabular information, such as content editing, sort, and column hiding. </li>
            <li><a href="examples/grid/LayoutGrids.html">Layout Grids</a>: Three example implementations of grids that are used to lay out widgets, including a collection of navigation links, a message recipients list, and a set of search results. </li>
          </ul>
        </section>
    </section>

    <section class="widget" id="link">
      <h3>Link</h3>

      <p>A <a href="#link" class="role-reference">link</a> widget provides an interactive reference to a resource either locally in the application or to an external resource.</p>
      <p class="note">Authors are strongly encouraged to use a native host language link element, such as an HTML <code>&lt;A&gt;</code> element with <code>href</code> attribute. As with other WAI-ARIA widget roles, applying the link role to an element will not cause browsers to enhance the element with standard link behaviors such as navigation to the link target or context menu actions. Providing these features of the element is the author's responsibility.</p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>

        <ul>
          <li><kbd>Enter</kbd> executes the link and moves focus to the link target.</li>
          <li><kbd>Shift + F10</kbd> opens associated context menu.</li>
        </ul>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
          <ul>
            <li>The element containing the link text has role of <a href="#link" class="role-reference">link</a>.</li>
          </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <ul>
          <li><a href="examples/link/link.html">Link role examples</a></li>
        </ul>
      </section>
    </section>

    <section class="widget" id="Listbox">
      <h3>Listbox</h3>

      <p>
        A <a href="#listbox" class="role-reference">listbox</a> widget presents a list of options and allows a user to select one or more of them.
        A listbox that allows a single option to be chosen is a single-select listbox; one that allows multiple options to be selected is a multi-select listbox.
      </p>
      <p>
        When screen readers present a listbox, they render the name, state, and position of each option in the list.
        The name of an option is a string calculated by the browser, typically from the content of the option element.
        As a flat string, the name does not contain any semantic information.
        Thus, if an option contains a semantic element, such as a heading, screen reader users will not have access to the semantics.
        In addition, the interaction model conveyed by the listbox role to assistive technologies does not support interacting with elements inside of an option.
        Because of these traits of the listbox widget, it does not provide an accessible way to present a list of interactive elements, such as links, buttons, or checkboxes.
        To present a list of interactive elements, see the <a href="#grid">grid</a> pattern.
      </p>
      <p>
        Avoiding very long option names facilitates understandability and perceivability for screen reader users. 
        The entire name of an option is spoken as a single unit of speech when the option is read.
        When too much information is spoken as the result of a single key press, it is difficult to understand.
        Long names inhibit perception by increasing the impact of interrupted speech because users typically have to re-read the entire option.
      And, if the user does not understand what is spoken, reading the name by character, word, or phrase may be a difficult operation for many screen reader users in the context of a listbox widget.
      </p>
      <p>
        Sets of options where each option name starts with the same word or phrase can also significantly degrade usability for keyboard and screen reader users.
        Scrolling through the list to find a specific option becomes inordinately time consuming for a screen reader user who must listen to that word or phrase repeated before hearing what is unique about each option.
        For example, if a listbox for choosing a city were to contain options where each city name were preceded by a country name, and if many cities were listed for each country, a screen reader user would have to listen to the country name before hearing each city name.
        In such a scenario, it would be better to have 2 list boxes, one for country and one for city.
      </p>
      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <p>For a vertically oriented listbox:</p>
        <ul>
          <li> When a single-select listbox receives focus:
            <ul>
              <li>If none of the options are selected before the listbox receives focus, the first option receives focus. Optionally, the first option may be automatically selected.</li>
              <li>If an option is selected before the listbox receives focus, focus is set on the selected option. </li>
            </ul>
          </li>
          <li>When a multi-select listbox receives focus:
            <ul>
              <li>If none of the options are selected before the listbox receives focus, focus is set on the first option and there is no automatic change in the selection state.</li>
              <li>If one or more options are selected before the listbox receives focus, focus is set on the first option in the list that is selected.</li>
            </ul>
          </li>
          <li><kbd>Down Arrow</kbd>: Moves focus to the next option. Optionally, in a single-select listbox, selection may also move with focus.</li>
          <li><kbd>Up Arrow</kbd>: Moves focus to the previous option. Optionally, in a single-select listbox, selection may also move with focus.</li>
           <li><kbd>Home</kbd> (Optional): Moves focus to first option. Optionally, in a single-select listbox, selection may also move with focus. Supporting this key is strongly recommended for lists with more than five options.</li>
           <li><kbd>End</kbd> (Optional): Moves focus to last option. Optionally, in a single-select listbox, selection may also move with focus. Supporting this key is strongly recommended for lists with more than five options.</li>
          <li>Type-ahead is recommended for all listboxes, especially those with more than seven options:
            <ul>
              <li>Type a character: focus moves to the next item with a name that starts with the typed character.</li>
              <li>Type multiple characters in rapid succession: focus moves to the next item with a name that starts with the string of characters typed.</li>
            </ul>
          </li>
          <li><strong>Multiple Selection</strong>:
            Authors may implement either of two interaction models to support multiple selection: 
            a recommended model that does not require the user to hold a modifier key, such as <kbd>Shift</kbd> or <kbd>Control</kbd>, while navigating the list
            or an alternative model that does require modifier keys to be held while navigating in order to avoid losing selection states.
            <ul>
              <li>Recommended selection model -- holding modifier keys is not necessary:
                <ul>
                  <li><kbd>Space</kbd>: changes the selection state of the focused option .</li>
                  <li><kbd>Shift + Down Arrow</kbd> (Optional): Moves focus to and selects the next option.</li>
                  <li><kbd>Shift + Up Arrow</kbd> (Optional): Moves focus to and selects the previous option.</li>
                  <li><kbd>Shift + Space</kbd> (Optional): Selects contiguous items from the most recently selected item to the focused item.</li>
                  <li><kbd>Control + Shift + Home</kbd> (Optional): Selects the focused option and all options up to the first option.</li>
                  <li><kbd>Control + Shift + End</kbd> (Optional): Selects the focused option and all options down to the last option.</li>
                  <li><kbd>Control + A</kbd> (Optional): Selects all options in the list. Optionally, if all options are selected, it may also unselect all options.</li>
                </ul>
              </li>
              <li>Alternative selection model -- moving focus without holding a <kbd>Shift</kbd> or <kbd>Control</kbd> modifier unselects all selected nodes except the focused node: 
              <ul>
                  <li><kbd>Shift + Down Arrow</kbd>: Moves focus to and toggles the selection state of the next option.</li>
                  <li><kbd>Shift + Up Arrow</kbd>: Moves focus to and toggles the selection state of the previous option.</li>
                  <li><kbd>Control + Down Arrow</kbd>: Moves focus to the next option without changing its selection state.</li>
                  <li><kbd>Control + Up Arrow</kbd>: Moves focus to the previous option without changing its selection state.</li>
                  <li><kbd>Control + Space</kbd> Changes the selection state of the focused option. </li>
                  <li><kbd>Shift + Space</kbd> (Optional): Selects contiguous items from the most recently selected item to the focused item.</li>
                  <li><kbd>Control + Shift + Home</kbd> (Optional): Selects the focused option and all options up to the first option.</li>
                  <li><kbd>Control + Shift + End</kbd> (Optional): Selects the focused option and all options down to the last option.</li>
                  <li><kbd>Control + A</kbd> (Optional): Selects all options in the list. Optionally, if all options are selected, it may also unselect all options.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
        <ol class="note">
          <li>DOM focus (the active element) is functionally distinct from the selected state. For more details, see <a href="#kbd_focus_vs_selection">this description of differences between focus and selection.</a></li>
          <li>
            The <code>listbox</code> role supports the <a class="property-reference" href="#aria-activedescendant">aria-activedescendant</a> property, 
            which provides an alternative to moving DOM focus among <code>treeitem</code> elements when implementing keyboard navigation. 
            For details, see <a href="#kbd_focus_activedescendant">Managing Focus in Composites Using aria-activedescendant</a>.
          </li>
          <li>
            In a single-select listbox, moving focus may optionally unselect the previously selected option and select the newly focused option.
            This model of selection is known as &quot;selection follows focus&quot;.
            Having selection follow focus can be very helpful in some circumstances and can severely degrade accessibility in others.
For additional guidance, see <a href="#kbd_selection_follows_focus">Deciding When to Make Selection Automatically Follow Focus</a>.
          </li>
          <li>If selecting or unselecting all options is an important function, implementing separate controls for these actions, such as buttons for &quot;Select All&quot; and &quot;Unselect All&quot;, significantly improves accessibility.</li>
        <li>
            If the options in a listbox are arranged horizontally:
            <ol>
              <li><kbd>Down Arrow</kbd> performs as <kbd>Right Arrow</kbd> is described above, and vice versa.</li>
              <li><kbd>Up Arrow</kbd> performs as <kbd>Left Arrow</kbd> is described above, and vice versa.</li>
            </ol>
          </li>
        </ol>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>An element that contains or owns all the listbox options has role <a href="#listbox" class="role-reference">listbox</a>.</li>
          <li>Each option in the listbox has role <a href="#option" class="role-reference">option</a> and is a DOM  descendant of the element with role <code>listbox</code> or is referenced by an <a href="#aria-owns" class="property-reference">aria-owns</a> property on the listbox element.</li>
          <li>If the listbox is not part of another widget, then it has a visible label referenced by <a href="#aria-labelledby" class="property-reference">aria-labelledby</a> on the element with role <code>listbox</code>.</li>
          <li>In a single-select listbox, the selected option has <a href="#aria-selected" class="property-reference">aria-selected</a> set to <code>true</code>. </li>
          <li>if the listbox supports multiple selection:
            <ul>
              <li> The element with role <code>listbox</code> has <a href="#aria-multiselectable" class="property-reference">aria-multiselectable</a> set to <code>true</code>. </li>
              <li>All selected options have <a href="#aria-selected" class="state-reference">aria-selected</a> set to <code>true</code>. </li>
              <li>All options that are not selected have <a href="#aria-selected" class="state-reference">aria-selected</a> set to <code>false</code>. </li>
            </ul>
          </li>
          <li>If the complete set of available options is not present in the DOM due to dynamic loading as the user scrolls, their <a href="#aria-setsize" class="property-reference">aria-setsize</a> and <a href="#aria-posinset" class="property-reference">aria-posinset</a> attributes are set appropriately. </li>
          <li>
            If options are arranged horizontally, the element with role <code>listbox</code> has <a href="#aria-orientation" class="property-reference">aria-orientation</a> set to <code>horizontal</code>.
            The default value of <code>aria-orientation</code> for <code>listbox</code> is <code>vertical</code>.
          </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p><a href="examples/listbox/listbox.html">Listbox Examples:</a> Two examples of the listbox pattern demonstrating differences between single-select and multi-select implementation as well as the use of action buttons with key shortcuts for arranging items in a list.</p>
      </section>
    </section>

    <section class="widget" id="menu">
      <h3>Menu or Menu bar</h3>
      <p>
        A <a href="#menu" class="role-reference">menu</a> is a widget that offers a list of choices to the user, such as a set of actions or functions.
        A menu is usually opened, or made visible, by activating a <a href="#menubutton">menu button</a>, choosing an item in a menu that opens a sub menu, or by invoking a command, such as <kbd>Shift + F10</kbd> in Windows, that opens a context specific menu.
        When a user activates a choice in a menu, the menu usually closes unless the choice opened a submenu.
      </p>

      <p>
        A menu that is visually persistent is a <a href="#menubar" class="role-reference">menubar</a>.
        A menubar is typically horizontal and is often used to create a menu bar similar to those found near the top of the window in many desktop applications, offering the user quick access to a consistent set of commands.
      </p>

      <p>A common convention for indicating that a menu item launches a dialog box is to append &quot;&#8230;&quot; (ellipsis) to the menu item label, e.g., &quot;Save as &#8230;&quot;.</p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <p class="note">
          Significant revisions to this keyboard subsection were made on October 31. 
          Please provide feedback in <a href="https://github.com/w3c/aria-practices/issues/120">issue 120</a>.
        </p>
        <ul>
          <li>
            When a <code>menu</code> opens, or when a <code>menubar</code> receives focus, 
            keyboard focus is placed on the first <code>menuitem</code>.
            All <code>menuitems</code> in a menu are focusable as described in <a href="#kbd_general_within"></a>.
          </li>
          <li><kbd>Enter</kbd>: 
            <ul>
              <li>If the focused <code>menuitem</code> has a submenu, opens the submenu and places focus on its first <code>menuitem</code>.</li>
              <li>Otherwise, activates the focused <code>menuitem</code>, <code>menuitemcheckbox</code>, or <code>menuitemradio</code> and closes the menu.</li>
            </ul>
          </li>
          <li><kbd>Space</kbd>: 
            <ul>
              <li>If focus is on a <code>menuitemcheckbox</code>, changes the state without closing the menu.</li>
              <li>If focus is on a <code>menuitemradio</code> that is not checked, without closing the menu, checks the focused <code>menuitemradio</code> and unchecks any other checked <code>menuitemradio</code> element in the same group.</li>
              <li>(Optional): If the focused <code>menuitem</code> has a submenu, opens the submenu and places focus on its first <code>menuitem</code>.</li>
              <li>(Optional): Activates the focused <code>menuitem</code> and closes the menu.</li>
            </ul>
          </li>
          <li><kbd>Down Arrow</kbd>:
            <ul> 
            <li>If the focused <code>menuitem</code> is in a vertical menu, moves focus to the next <code>menuitem</code>, optionally wrapping from the last to the first. </li>
              <li>If the focused <code>menuitem</code> is in a horizontal menubar or menu and the <code>menuitem</code> has a submenu, opens the submenu and places focus on its first <code>menuitem</code>.</li>
              <li>Otherwise, if the focused <code>menuitem</code> is in a horizontal submenu of a parent vertical menubar, closes the submenu and moves focus to the first <code>menuitem</code> contained in the submenu opened by the next <code>menuitem</code> in the parent menubar. </li>
            </ul>
          </li>
          <li><kbd>Up Arrow</kbd>:
            <ul> 
            <li>If the focused <code>menuitem</code> is in a vertical menu, moves focus to the previous <code>menuitem</code>, optionally wrapping from the first to the last. </li>
            <li>If the focused <code>menuitem</code> is in a horizontal submenu of a parent horizontal menu, closes the submenu and returns focus to the <code>menuitem</code> in the parent menu that opened the submenu. </li>
            <li>Otherwise, if the focused <code>menuitem</code> is in a horizontal submenu of a parent vertical menubar, moves focus to the first <code>menuitem</code> contained in the submenu opened by the previous <code>menuitem</code> in the parent menubar. </li>
            </ul>
          </li>
          <li><kbd>Right Arrow</kbd>: 
            <ul>
            <li>If the focused <code>menuitem</code> is in a horizontal menu, moves focus to the next <code>menuitem</code>, optionally wrapping from the last to the first. </li>
              <li>If the focused <code>menuitem</code> is in a vertical menu and the <code>menuitem</code> has a submenu, opens the submenu and places focus on its first <code>menuitem</code>. </li>
              <li>Otherwise, if the focused <code>menuitem</code> is in a vertical submenu of a parent horizontal menubar, closes the submenu and moves focus to the first <code>menuitem</code> contained in the submenu opened by the next <code>menuitem</code> in the parent menubar.</li>
            </ul>
          </li>
          <li><kbd>Left Arrow</kbd>:
          <ul>
            <li>If the focused <code>menuitem</code> is in a horizontal menu, moves focus to the previous <code>menuitem</code>, optionally wrapping from the first to the last. </li>
              <li>If the focused <code>menuitem</code> is in a vertical submenu of a parent vertical menu, closes the submenu and returns focus to the <code>menuitem</code> that opened the submenu.</li>
              <li>Otherwise, if the focused <code>menuitem</code> is in a vertical submenu of a parent horizontal menubar, closes the submenu and moves focus to the first <code>menuitem</code> contained in the submenu opened by the previous <code>menuitem</code> in the parent menubar.</li>
            </ul>
          </li>
          <li><kbd>Home</kbd>: If arrow key wrapping is not supported, moves focus to the first <code>menuitem</code> in the menu that contains focus.</li>
          <li><kbd>End</kbd>: If arrow key wrapping is not supported, moves focus to the last <code>menuitem</code> in the menu that contains focus.</li>
          <li>Any key that corresponds to a printable character (Optional): Move focus to   the next menu item in the current menu whose label begins with that printable character.</li>
          <li><kbd>Escape</kbd>: Close the menu that contains focus and return focus to   the element or context, e.g., menu button or parent <code>menuitem</code>, from which the menu was opened. </li>
          <li><kbd>Tab</kbd>: Moves focus to the next element in the tab sequence, and if the <code>menuitem</code> that had focus is not in a menubar, closes its menu and all open parent menus.</li>
          <li><kbd>Shift + Tab</kbd>: Moves focus to the previous element in the tab sequence, and if the <code>menuitem</code> that had focus is not in a menubar, closes its menu and all open parent menus.</li>
        </ul>
        <ol class="note">
          <li>Disabled menu items should be focusable but can not be activated. </li>
          <li>A <a href="#separator" class="role-reference">separator</a> in a menu is not focusable or interactive.</li>
          <li>
            If a menu is opened or a menubar receives focus as a result of a context action, <kbd>Escape</kbd> or <kbd>Enter</kbd> may return focus to   the invoking context. 
            For example, a rich text editor may have a menubar that receives focus when a shortcut key, e.g., <kbd>alt + F10</kbd>, is pressed while editing. 
            In this case, <kbd>Escape</kbd> or activating a command from the menu may return focus to the editor.
          </li>
          <li>
            Although it is recommended that authors avoid doing so, some implementations of navigation menubars may have <code>menuitem</code> elements that both perform a function and open a submenu.
            In such implementations, <kbd>enter</kbd> and <kbd>Space</kbd> perform a navigation function, e.g., load new content,
            while <kbd>Down Arrow</kbd>, in a horizontal menubar, opens the submenu associated with that same <code>menuitem</code>.
          </li>
        </ol>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>A menu is a container of items that represent choices. The element serving as the menu has a role of either <a href="#menu" class="role-reference">menu</a> or   <a href="#menubar" class="role-reference">menubar</a>. </li>
          <li>The items contained in a menu are child elements of the containing menu or menubar and have any of the following roles:
            <ul>
              <li><a href="#menuitem" class="role-reference">menuitem</a></li>
              <li><a href="#menuitemcheckbox" class="role-reference">menuitemcheckbox</a></li>
              <li><a href="#menuitemradio" class="role-reference">menuitemradio</a></li>
            </ul>
          </li>
          <li>One of the following approaches is used to enable scripts to move focus among items in a menu as described in <a href="#kbd_general_within"></a>:
            <ul>
              <li>The menu container has <code>tabindex</code> set to <code>-1</code> or <code>0</code> and <a href="#aria-activedescendant" class="property-reference">aria-activedescendant</a> set to the ID of the focused item. </li>
              <li>Each item in the menu has <code>tabindex</code> set to <code>-1</code>, except in a menubar, where the first item has <code>tabindex</code> set to <code>0</code>. </li>
            </ul>
          </li>
          <li>If activating a <a href="#menuitem" class="role-reference">menuitem</a> opens a submenu, the menuitem has <a href="#aria-haspopup" class="property-reference">aria-haspopup</a> set to <code>true</code>. </li>
          <li>When a <a href="#menuitemcheckbox" class="role-reference">menuitemcheckbox</a> or <a href="#menuitemradio" class="role-reference">menuitemradio</a> is checked, <a href="#aria-checked" class="property-reference">aria-checked</a> is set to <code>true</code>. </li>
          <li>When a menu item is disabled, <a href="#aria-disabled" class="state-reference">aria-disabled</a> is set to <code>true</code>.</li>
          <li>Items in a menu may be divided into groups by placing an element with a role of <a href="#separator" class="role-reference">separator</a> between groups. For example, this technique should be used when a menu contains a set of <a href="#menuitemradio" class="role-reference">menuitemradio</a> items. </li>
          <li>All <a href="#separator" class="role-reference">separators</a> should have <a href="#aria-orientation" class="property-reference">aria-orientation</a> consistent with the separator's orientation. </li>
        </ul>
        <p class="note">If <a href="#aria-owns" class="property-reference">aria-owns</a> is set on the menu container to include elements that are not DOM children of the container, those elements will appear in the reading order in the sequence they are referenced and after any items that are DOM children. Scripts that manage focus need to ensure the visual focus order matches this assistive technology reading order. </p>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <ul>
          <li><a href="examples/menubar/menubar-1/menubar-1.html">Navigation Menubar</a>: Demonstrates a menubar that provides site navigation.</li>
          <li><a href="examples/menubar/menubar-2/menubar-2.html">Editor Menubar</a>: Demonstrates menu radios and menu checkboxes in submenus of a menubar that provides text formatting commands for a text field.</li>
        </ul>
      </section>
    </section>

    <section class="widget" id="menubutton"><h3>Menu Button</h3>
      <p>A menu button is a <a href="#button">button</a> that opens a <a href="#menu">menu</a>. It is often styled as a typical push button with a downward pointing arrow or triangle to hint that activating the button will display a menu.</p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <ul>
          <li>With focus on the button:
            <ul>
              <li><kbd>Space</kbd> and <kbd>Enter</kbd>: open the menu and place focus on the first menu item. </li>
              <li>(Optional) <kbd>Down Arrow</kbd>: opens the menu and moves focus to the first menu item. </li>
            </ul>
          </li>
          <li>The keyboard behaviors needed after the menu is open are described in <a href="#menu"></a>.</li>
        </ul>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
           <li>The element that opens the menu has role <a href="#button" class="role-reference">button</a>.</li>
           <li>The element with role <code>button</code> has <a href="#aria-haspopup" class="property-reference">aria-haspopup</a> set to <code>true</code>.</li>
           <li>The roles, states, and properties needed for the menu opened by the button are described in <a href="#menu"></a>. </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <ul>
          <li><a href="examples/menu-button/menu-button-1.html">Menu button with popup menu for actions</a></li>
          <li><a href="examples/menu-button/menu-button-2.html">Menu button with popup menu for links</a></li>
      </section>
    </section>

    <section class="widget" id="radiobutton">
            <h3>Radio Group</h3>
            <p>A radio group is a set of checkable buttons, known as radio buttons, where only
                one button in the set may be in a checked state.</p>

            <section class="notoc">
                <h4>Keyboard Interaction</h4>
                <ul>
                    <li>When a radio group is receiving focus:
                        <ul>
                            <li><kbd>Tab</kbd> and <kbd>Shift+Tab</kbd>: move focus to the
                                checked radio button. If none of the radio buttons are checked, they
                                move focus to the first radio button in the group.</li>
                        </ul>
                    <li>When focus is on a radio button in a radio group:
                        <ul>
                            <li><kbd>Tab</kbd>: moves focus to the element in the page tab
                                sequence that follows the radio group.</li>
                            <li><kbd>Shift+Tab</kbd>: moves focus to the element in the page
                                tab sequence that precedes the radio group.</li>
                            <li><kbd>Space</kbd>: checks the focussed radio button if it is not
                                already checked.</li>
                            <li><kbd>Right Arrow</kbd> and <kbd>Down Arrow</kbd>: move focus to
                                the next radio button in the group, uncheck the previously focused
                                button, and check the newly focused button. If focus is on the last
                                button, focus moves to the first button.</li>
                            <li><kbd>Left Arrow</kbd> and <kbd>Up Arrow</kbd>: move focus to
                                the previous radio button in the group, uncheck the previously
                                focused button, and check the newly focused button. If focus is on
                                the first button, focus moves to the last button.</li>
                        </ul>
                </ul>
                <p class="note">
                    The behavior of the <kbd>Tab</kbd> key described above differs slightly from the
                    behavior provided by some browsers for native HTML radio groups. In some
                    browsers, if none of the radio buttons are selected, <kbd>Shift+Tab</kbd> places
                    focus on the last radio button instead of the first radio button.
                </p>
            </section>

            <section class="notoc">
                <h4>WAI-ARIA Roles, States, and Properties</h4>
                <ul>
                    <li>
                        The radio buttons are contained in or owned by an element with role
                        <a href="#radiogroup" class="role-reference">radiogroup</a>
                        .
                    </li>
                    <li>
                        Each radio button element has role
                        <a href="#radio" class="role-reference">radio</a>.
                    </li>
                    <li>
                        If a radio button is checked, the <code>radio</code> element has
                        <a href="#aria-checked" class="state-reference">aria-checked</a>
                        set to <code>true</code>. If it is not checked, it has
                        <a href="#aria-checked" class="state-reference">aria-checked</a>
                        set to <code>false</code>.
                    </li>
                    <li>
                        Each <code>radio</code> element is labeled by its content, has a visible
                        label referenced by
                        <a href="#aria-labelledby" class="property-reference">aria-labelledby</a>,
                        or has a label specified with
                        <a href="#aria-label" class="property-reference">aria-label</a>.
                    </li>
                    <li>
                        The <code>radiogroup</code> element has a visible label referenced by
                        <a href="#aria-labelledby" class="property-reference">aria-labelledby</a>
                        or has a label specified with
                        <a href="#aria-label" class="property-reference">aria-label</a>.
                    </li>
                    <li>
                        If elements providing additional information about either the radio group or
                        each radio button are present, those elements are referenced by the <code>radiogroup</code>
                        element or <code>radio</code> elements with the
                        <a href="#aria-describedby" class="property-reference">aria-describedby</a>
                        property.
                    </li>
                </ul>
            </section>

            <section class="notoc">
                <h4>Example</h4>
                <p>
                    <a href="examples/radio/radio.html">Radio Group Examples</a>
                </p>
            </section>

        </section>

    <section class="widget" id="slider">
      <h3>Slider</h3>

      <p>A slider is an input where the user selects a value from within a given range. Sliders typically have a slider thumb that when moved will change the current value within the bar or track.</p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <ul>
          <li><kbd>Right Arrow</kbd> and <kbd>Up Arrow</kbd>: Increase the value of the slider.</li>
          <li><kbd>Left Arrow</kbd> and <kbd>Down Arrow</kbd>: Decrease the value of the slider.</li>
          <li><kbd>Home</kbd> and <kbd>End</kbd>: Set the slider to the first and last values of the slider.</li>
          <li><kbd>Tab</kbd>: Moves focus into and out of the slider.</li>
          <li><kbd>Page Up</kbd> and <kbd>Page Down</kbd> (Optional): Increment or decrement the slider by an amount larger than the step changes made by the arrow keys.</li>
        </ul>

        <ol class="note">
          <li>Focus is placed on the slider (the visual object that the mouse user would move, also known as the thumb) </li>
          <li>In some circumstances, an author may reverse the direction of the value change for the keys specified above, e.g., make <kbd>Up Arrow</kbd> decrease the value, if the author is certain doing so will result in a better user experience. </li>
        </ol>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The slider control has the role <a class="role-reference" href="#slider">slider</a>.  </li>
          <li>Sliders require the <a class="property-reference" href="#aria-valuemin">aria-valuemin</a>, <a class="property-reference" href="#aria-valuemax">aria-valuemax</a>, and <a class="property-reference" href="#aria-valuenow">aria-valuenow</a> properties representing the minimum possible value of the slider, the maximum possible value, and the current value.  All of these are decimal numbers.  The minimum and maximum are typically fixed and do not change.  </li>
          <li>Sometimes the value is not user readable, such as a number for the day of the week, e.g., "1". In those cases, use the <a class="property-reference" href="#aria-valuetext">aria-valuetext</a> property to provide a human readable string for the slider's value, e.g. "Monday". </li>
          <li>It is recommended that authors provide a visible label for the slider, referencing it using <a href="#aria-labelledby" class="property-reference">aria-labelledby</a>.  </li>
          <li>If the slider is vertical specify <a class="property-reference" href="#aria-orientation">aria-orientation</a>="vertical"</li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <ul>
          <li><a href="examples/slider/slider-1.html">Horizontal Slider Examples (e.g. color picker)</a></li>
          <li><a href="examples/slider/slider-2.html">Vertical and Text Slider Examples (e.g. Thermostat Controls)</a></li>
        </ul>
      </section>
    </section>

    <section class="widget" id="slidertwothumb">
      <h3>Slider (Multi-Thumb)</h3>

      <p>
        A multi-thumb slider is a slider with multiple slider thumbs designed to change 2 or more different values for an object it controls.
        In most cases the user is selecting a maximum and minimum value to create a range, but in some cases the 2 (or more) values selected are completely independent.
      </p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <p>This range slider allows author to modify multiple values for an object.</p>
        <ul>
          <li><kbd>Tab</kbd> to the first slider thumb.</li>
          <li>Second <kbd>Tab</kbd> moves to next slider thumb..</li>
          <li>Third <kbd>Tab</kbd> moves to the next slider thumb or if there are no   more, it moves to the next tab stop on the page. </li>
          <li><kbd>Shift + Tab</kbd> moves backwards through the tabs.</li>
          <li>With focus on a thumb: Same as <a href="#slider">Slider</a> above.
            <ul>
              <li><kbd>Right Arrow</kbd> and <kbd>Up Arrow</kbd> increase the value of the slider. If applicable this is constrained by the value of the other thumb. </li>
              <li><kbd>Left Arrow</kbd> and <kbd>Down Arrow</kbd> decrease the value of the slider. If applicable this is constrained by the value of the other thumb. </li>
              <li><kbd>Home</kbd> and <kbd>End</kbd> move to the first and last values of the slider. If applicable this is constrained by the value of the other thumb. </li>
              <li><kbd>Page Up</kbd> and <kbd>Page Down</kbd> optionally increment or decrement the   slider by a given amount. If applicable this is constrained by the value of the other thumb. </li>
            </ul>
          </li>
        </ul>

        <ol class="note">
          <li>Focus is placed on one of the thumbs of the slider.</li>
          <li>All thumbs are in the tab order.</li>
          <li>If the current value of a slider crosses over one of the other sliders, the tab order remains the same.  Example.  If a high range slider is moved so that its current value is below the current value of a low range slider, the thumb will visually appear to be before the low range slider.  This should not change the tab order of the slider. </li>
          <li>In some circumstances, an author may reverse the direction of the value change for the keys specified above, e.g., make <kbd>Up Arrow</kbd> decrease the value, if the author is certain doing so will result in a better user experience. </li>
        </ol>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>Each slider control has the role <a class="role-reference" href="#slider">slider</a>.  </li>
          <li>Each slider requires the <a class="property-reference" href="#aria-valuemin">aria-valuemin</a>, <a class="property-reference" href="#aria-valuemax">aria-valuemax</a>, and <a class="property-reference" href="#aria-valuenow">aria-valuenow</a> properties representing the minimum possible value of the slider, the maximum possible value, and the current value.  All of these are decimal numbers.  The maximum of the lower slider limits the minimum of the upper slider and vice versa.  </li>
          <li>Sometimes the value is not user readable, such as a number for the day of the week, e.g., "1". In those cases, use the <a class="property-reference" href="#aria-valuetext">aria-valuetext</a> property to provide a human readable string for the slider's value, e.g. "Monday". </li>
          <li>It is recommended that authors provide a visible label for the multi-thumb slider, referencing it using <a href="#aria-labelledby" class="property-reference">aria-labelledby</a>.  </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p class="note">Any examples referenced here that are hosted outside www.w3.org may have changed and may not accurately exemplify the guidance in this section. The APG task force is developing examples for APG version 1.1 that will be directly incorporated into the guide.</p>

        <ul>
          <li><a href="http://www.oaa-accessibility.org/examplep/slider1/" target="_blank" rel="nofollow">Open Ajax Alliance Sliders</a> (see second example on page)</li>
          <li><a href="http://files.paciellogroup.com/blogmisc/samples/aria/slider/doubleslider.html" target="_blank" rel="nofollow">Paciello Group double slider</a></li>
        </ul>
      </section>
    </section>

    <section class="widget" id="spinbutton">
      <h3>Spinbutton</h3>
      <p>A widget that allows users to choose a value from a set, or range, of discrete values. For example, select a number from 1 to 59 for the minute of an hour when setting an alarm.</p>

      <p>A spin button provides ways to easily increment and decrement the value. If the range is large, it may support changing the value by both a single step and by multiple steps at once. For instance, in the alarm example, the user may be able to move by 1 minute with the arrow keys and by 10 minutes with PageUp and PageDown.</p>

      <p>A spinbutton usually includes a text field that displays the current value and allows users to directly edit it.</p> </td>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>

        <p>The associated text field generally supports standard text entry operations such as selection of characters, deletions, insertions, and caret movement using the <kbd>Right Arrow</kbd> and <kbd>Left Arrow</kbd> keys.  The exception is when the spinbutton's value space is restricted and the associated script limits the characters.  For example, an hour-and-minute spinner would allow only the digits 1-59, the colon ':', and the characters 'AM' and 'PM'.  If the user typed any other character, it would not change the contents of the text field nor the value of the spinbutton. </p>
        <ul>
          <li><kbd>Up Arrow</kbd> increases the value. </li>
          <li><kbd>Down Arrow</kbd> decreases the value. </li>
          <li><kbd>Home</kbd> and <kbd>End</kbd> key  move to the maximum or minimum values. </li>
          <li>Optional: <kbd>Page Up</kbd> and <kbd>Page Down</kbd> increase or   decrease the value in larger steps. </li>
          <li><kbd>Tab</kbd> key moves into and out of the widget. </li>
        </ul>
        <p class="note">Focus should remain on the edit field </p>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The widget has the role <a class="role-reference" href="#spinbutton">spinbutton</a>.  </li>
          <li>Spinbuttons support the <a class="property-reference" href="#aria-valuemin">aria-valuemin</a>, <a class="property-reference" href="#aria-valuemax">aria-valuemax</a>, and <a class="property-reference" href="#aria-valuenow">aria-valuenow</a> properties representing the minimum possible value of the spinner, the maximum possible value, and the current value.  All of these are decimal numbers.  The minimum and maximum are typically fixed.  </li>
          <li>Sometimes the value is not user readable, such as a number for the day of the week, e.g., "1". In those cases, use the <a class="property-reference" href="#aria-valuetext">aria-valuetext</a> property to provide a human readable string for the slider's value, e.g. "Monday". </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p class="note">Any examples referenced here that are hosted outside www.w3.org may have changed and may not accurately exemplify the guidance in this section. The APG task force is developing examples for APG version 1.1 that will be directly incorporated into the guide.</p>
        <ul>
          <li><a href="http://www.oaa-accessibility.org/examplep/spinbutton1/" rel="nofollow" target="_blank">Open Ajax Alliance Spinbutton</a></li>
          <li><a href="http://archive.dojotoolkit.org/nightly/dojotoolkit/dijit/tests/form/test_Spinner.html" rel="nofollow">dojo/dijit nightly build</a></li>
        </ul>
      </section>
    </section>

    <section class="widget" id="table">
      <h3>Table</h3>
      <p>Drafting this section is <a href="https://github.com/w3c/aria-practices/issues/90">issue 90</a>. </p>
      <p>
        [Place holder for a to-be-written section about data tables]
        While writing the grid pattern, the topic of data tables came up because the grid pattern has text clarifying when to use grid verses when to use table.
        There was a suggestion to cover tables at the same time in the grid section.
        That made the grid pattern section feel overwhelming so adding a placeholder for a potential table section here.
        The grid pattern links to this section.
      </p>
    </section>

    <section class="widget" id="tabpanel">
      <h3>Tabs</h3>

      <p>
        Tabs are a set of layered sections of content, known as tab panels, that display one panel of content at a time.
        Each tab panel has an associated tab element, that when activated, displays the panel.
        The list of tab elements is arranged along one edge of the currently displayed panel, most commonly the top edge.
      </p>

      <p>Terms used to describe this design pattern include:</p>

      <dl>
        <dt>Tabs or Tabbed Interface</dt>
        <dd>A set of tab elements and their associated tab panels.</dd>
        <dt>Tab List</dt>
        <dd>A set of tab elements contained in a <a href="#tablist" class="role-reference">tablist</a> element.</dd>
        <dt><a href="#tab" class="role-reference">tab</a></dt>
        <dd>An element in the tab list that serves as a label for one of the tab panels and can be activated to display that panel. </dd>
        <dt><a href="#tabpanel" class="role-reference">tabpanel</a></dt>
        <dd>The element that contains the content associated with a tab.</dd>
      </dl>

      <p>
        When a tabbed interface is initialized, one tab panel is displayed and its associated tab is styled to indicate that it is active.
        When the user activates one of the other tab elements, the previously displayed tab panel is hidden, the tab panel associated with the activated tab becomes visible, and the tab is considered "active".
      </p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>

        <p>For the tab list:</p>

        <ul>
          <li>
            <kbd>Tab</kbd>: When the tab list is receiving focus, places focus on the active <code>tab</code> element .
            When the tab list contains the focus, moves focus to the next element in the page tab sequence outside the tablist, which is typically either the first focusable element inside the tab panel or the tab panel itself.
          </li>
          <li>When focus is on a tab element in a horizontal tab list:
            <ul>
              <li>
                <kbd>Left Arrow</kbd>: moves focus to the previous tab.
                If focus is on the first tab, moves focus to the last tab.
                Optionally, activates the newly focused tab (See note below).
              </li>
              <li>
                <kbd>Right Arrow</kbd>: Moves focus to the next tab.
                If focus is on the last tab element, moves focus to the first tab.
                Optionally, activates the newly focused tab (See note below).
              </li>
            </ul>
          </li>
          <li>When focus is on a tab in a tablist with either horizontal or vertical orientation:
            <ul>
              <li><kbd>Space or Enter</kbd>: Activates the tab if it was not activated automatically on focus.</li>
              <li><kbd>Home</kbd> (Optional): Moves focus to the first tab</li>
              <li><kbd>End</kbd> (Optional): Moves focus to the last tab.</li>
              <li><kbd>Shift + F10</kbd>: If the tab has an associated pop-up menu, opens the menu. </li>
              <li>
                <kbd>Delete</kbd> (Optional): If deletion is allowed, deletes (closes) the current tab element and its associated tab panel.
                If any tabs remain, sets focus to the tab following the tab that was closed and activates the newly focused tab.
                Alternatively, or in addition, the delete function is available in a context menu.
              </li>
            </ul>
          </li>
        </ul>
        <ol class="note">
          <li>
            It is recommended that tabs activate automatically when they receive focus as long as their associated tab panels are displayed without noticeable latency.
            This typically requires tab panel content to be preloaded.
            Otherwise, automatic activation slows focus movement, which significantly hampers users' ability to navigate efficiently across the tab list.
          </li>
          <li>
            If the tabs in a tab list are arranged vertically:
            <ol>
              <li><kbd>Down Arrow</kbd> performs as <kbd>Right Arrow</kbd> is described above.</li>
              <li><kbd>Up Arrow</kbd> performs as <kbd>Left Arrow</kbd> is described above.</li>
            </ol>
          </li>
          <li>If the tab list is horizontal, it does not listen for <kbd>Down Arrow</kbd> or <kbd>Up Arrow</kbd> so those keys can provide their normal browser scrolling functions even when focus is inside the tab list.</li>
        </ol>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
        <li>The element that serves as the container for the set of tabs has role  <a class="role-reference" href="#tablist">tablist</a>. </li>
        <li>Each element that serves as a tab has role <a class="role-reference" href="#tab">tab</a> and is contained within the element with role <code>tablist</code>.</li>
          <li>Each element that contains the content panel for a <code>tab</code> has role <a class="role-reference" href="#tabpanel">tabpanel</a>.</li>
          <li>Each element with role <code>tab</code> has the property <a href="#aria-controls" class="property-reference">aria-controls</a> referring to its associated <code>tabpanel</code> element.</li>
          <li>The active <code>tab</code> element has the state <a href="#aria-selected" class="state-reference">aria-selected</a> set to <code>true</code> and all other <code>tab</code> elements have it set to <code>false</code>.</li>
          <li>Each element with role <code>tabpanel</code> has the property <a href="#aria-labelledby" class="property-reference">aria-labelledby</a> referring to its associated <code>tab</code> element. </li>
          <li>If a <code>tab</code> element has a pop-up menu, it has the property <a href="#aria-haspopup" class="property-reference">aria-haspopup</a> set to <code>true</code>. </li>
          <li>
            If the <code>tablist</code> element is vertically oriented, it has the property <a href="#aria-orientation" class="property-reference">aria-orientation</a> set to <code>vertical</code>.
            The default value of <code>aria-orientation</code> for a <code>tablist</code> element is <code>horizontal</code>.
        </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <ul>
            <li><a href="examples/tabs/tabs.html">Tabs widget code example</a></li>
        </ul>
      </section>
    </section>

    <section class="widget" id="toolbar">
      <h3>Toolbar</h3>
      <p>A <a class="role-reference" href="#toolbar">toolbar</a> is a container for grouping a set of controls, such as buttons, menubuttons, or checkboxes.</p>
      <p>
        When a set of controls is visually presented as a group, the <code>toolbar</code> role can be used to communicate the presence and purpose of the grouping to screen reader users.
        Grouping controls into toolbars can also be an effective way of reducing the number of tab stops in the keyboard interface.
      </p>
      <p>When designing and implementing toolbars, it is strongly recommended that authors:</p>
      <ol>
        <li>Implement focus management so there is one stop in the keyboard tab sequence for the toolbar and arrow keys move focus among the contained controls.</li>
        <li>Avoid including controls that require arrow keys to operate, such as textbox or radio group. If unavoidable, include only one such control and make it the last element .</li>
        <li>Use toolbar as a grouping element only if the group contains 3 or more controls.</li>
      </ol>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <ul>
          <li>
            <kbd>Tab</kbd>: Moves focus into and out of the toolbar.
            When focus moves into the toolbar, the first enabled control receives focus.
            Optionally, if the toolbar has previously contained focus, the control that last had focus may receive focus.
          </li>
          <li>For a horizontal toolbar (the default):
            <ul>
              <li><kbd>Left Arrow</kbd>: Moves focus to the previous control.  Optionally, focus movement may wrap from the first element to the last element. </li>
              <li><kbd>Right Arrow</kbd>: Moves focus to the next control.  Optionally, focus movement may wrap from the last element to the first element. </li>
            </ul>
          </li>
        </ul>
        <ol class="note">
          <li>If the items in a toolbar are arranged vertically:
            <ol>
              <li><kbd>Down Arrow</kbd> performs as <kbd>Right Arrow</kbd> is described above. </li>
              <li><kbd>Up Arrow</kbd> performs as <kbd>Left Arrow</kbd> is described above. </li>
            </ol>
          </li>
          <li>Typically, disabled elements are not focusable when navigating with a keyboard. However, in circumstances where discoverability of a function is crucial, authors may choose to make disabled controls focusable so screen reader users are more likely to be aware of their presence. </li>
          <li>In applications where quick access to a toolbar is important, such as accessing an editor's toolbar from its text area, it is recommended that authors provide a documented shortcut key for moving focus from the relevant context to its corresponding toolbar. </li>
        </ol>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The element has the role <a class="role-reference" href="#toolbar">toolbar</a>.  </li>
          <li>Labeling with <a href="#aria-label" class="property-reference">aria-label</a> is recommended, especially if the user interface includes multiple toolbars. </li>
          <li>If the controls are arranged vertically, the toolbar element has <a href="#aria-orientation" class="property-reference">aria-orientation</a> set to <code>vertical</code>. The default orientation is horizontal.</li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p><a href="examples/toolbar/toolbar.html">Toolbar Example</a>: A toolbar including buttons, links, and checkboxes that uses roving tabindex to manage focus.</p>
      </section>
    </section>

    <section class="widget" id="tooltip">
      <h3>Tooltip Widget</h3>
      <p>
        Popup that displays a description for an element when a user hovers over or focuses on that element.
        It should popup automatically when the user gives input focus to the widget or element with which it is associated.
        The tooltip widget can be dismissed by pressing the <kbd>Escape</kbd> key or by other methods noted below.
        The tooltip widget differs from the <a href="#dialog_tooltip">Dialog (Tooltip)</a> in that it does not receive focus at any time.
      </p>
      <p>The tooltip may appear immediately or there may be a small delay before the tooltip appears.</p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>

        <p><kbd>Escape</kbd>: Dismisses the Tooltip.</p>
        <ol class="note">
          <li>The trigger element to which the tooltip is attached,   e.g., a link, should never actually lose input focus. </li>
          <li>If the tooltip is invoked when the trigger element   gets focus, then it should be dismissed when it no longer has focus (onBlur). If   the tooltip is invoked with mouseIn, then it should be dismissed with a   mouseOut. </li>
          <li>If nested widgets use the same keys, e.g.,   <kbd>Escape</kbd>, then they should be handled in a Last In First Out (LIFO) manner. For example, an editable grid contains gridcells which contain date fields. The user invokes Actionable mode on the grid and then interacts with the Date Field to invoke the Date Picker. At this point the first press of the <kbd>Escape</kbd> key will close the Date Picker, the second press will exit Actionable mode and return to Navigation mode.</li>
        </ol>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>Uses the WAI-ARIA role <span class="widget-description"><a href="#tooltip" class="role-reference">tooltip</a></span>. </li>
          <li>The element that the tooltip is for references the tooltip using <a href="#aria-describedby" class="property-reference">aria-describedby</a>. </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p class="note">Any examples referenced here that are hosted outside www.w3.org may have changed and may not accurately exemplify the guidance in this section. The APG task force is developing examples for APG version 1.1 that will be directly incorporated into the guide.</p>
        <ul>
          <li><a href="http://www.oaa-accessibility.org/examplep/tooltip1/" target="_blank" rel="nofollow">Open Ajax Alliance tooltip</a></li>
          <li><a href="http://www.oaa-accessibility.org/examplep/tooltip2/" target="_blank" rel="nofollow">Open Ajax Alliance tooltip using ARIA CSS selectors</a></li>
          <li><a href="http://archive.dojotoolkit.org/nightly/dojotoolkit/dijit/tests/test_Tooltip.html" target="_blank" rel="nofollow">Dojo nightly</a></li>
        </ul>
      </section>
    </section>

    <section class="widget" id="TreeView">
      <h3>Tree View</h3>
      <p>
        A tree view is a component to navigate hierarchical lists.
        It is made up of one or more top level nodes.
        A node may have children or it may be an end node.
        Nodes with children can be expanded or collapsed - when expanded its child nodes are visible.
        When collapsed the children are not visible.
        There is generally some sort of visual indication whether a node has children and can be expanded.
        Any number of nodes can be expanded at a time and child nodes may contain children.
      </p>
      <p>
        An example of a Tree View is a File Navigator where a tree view is used to navigate the directories and files on a file system.
        The directory nodes can be expanded and collapsed to reveal its contained subdirectories and files.
        Terms for understanding tree views include:
      </p>
      <dl>
        <dt>node</dt>
        <dd>An item in a tree. </dd>
        <dt>parent node</dt>
        <dd>Node with children. It can be opened / expanded or closed / collapsed </dd>
        <dt>open node</dt>
        <dd>Expanded node with children; first-level children are visible. </dd>
        <dt>closed node</dt>
        <dd>Closed node with children; the children are not visible. </dd>
        <dt>end node</dt>
        <dd>Node with no children </dd>
      </dl>

      <p>Nodes can be focused and/or selected. There must be visual distinction between focused and selected nodes. </p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>
        <ul>
          <li>On first load of the tree component, the top level node is in the tab order. </li>
          <li>One and only one node of the tree component is in the tab order of the page at any time. </li>
          <li>The last visited node in the tree control is retained in the tab order when the user navigates away from the tree control. </li>
          <li>Arrowing to an item with the keyboard will focus and select the node. Any previous selections are cleared </li>
          <li><kbd>Up Arrow</kbd> and <kbd>Down arrow</kbd> keys move between visible nodes. </li>
          <li><kbd>Left arrow</kbd> key on an expanded node closes the node. </li>
          <li><kbd>Left arrow</kbd> key on a closed or end node moves focus to the node's parent. </li>
          <li><kbd>Right arrow</kbd> key expands a closed node, moves to the first child of an open node, or does nothing on an end node. </li>
          <li><kbd>Enter</kbd> key performs the default action on end nodes. </li>
          <li>Typing a letter key moves focus to the next instance of a visible node whose title begins with that letter. </li>
          <li><kbd>Home</kbd> key moves to the top node in the tree view. </li>
          <li><kbd>End</kbd> key moves to the last visible node in the tree view. </li>
          <li><kbd>Control + Arrow</kbd> to an item with the keyboard focuses the item (but does not select it). Previous selections are maintained, provided that the <kbd>Control</kbd> key is not released or that some other keyboard function is not performed. </li>
          <li><kbd>Control + Space</kbd> with focus on an item toggles the selection of the item. </li>
          <li><kbd>Shift + Up Arrow</kbd> extends selection up one node. </li>
          <li><kbd>Shift + Down Arrow</kbd> extends selection down one node. </li>
          <li><kbd>Shift + Home</kbd> extends selection up to the top-most node. </li>
          <li><kbd>Shift + End</kbd> extends selection down to the last node. </li>
          <li><kbd>*</kbd>(asterisk) - on numeric keypad (optional) expands all siblings at the current node's level. </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The tree view container has a role of <a class="role-reference" href="#tree">tree</a>.</li>
          <li>Each node in a tree has the role <a class="role-reference" href="#treeitem">treeitem</a> and should be a DOM child of tree.</li>
          <li>If is not a DOM child of tree, then it should be referenced by <a href="#aria-owns" class="property-reference">aria-owns</a> from its logical parent node.</li>
          <li>If all nodes in the tree are not DOM children of the tree, then set their <a href="#aria-level" class="property-reference">aria-level</a>, <a href="#aria-setsize" class="property-reference">aria-setsize</a> and <a href="#aria-posinset" class="property-reference">aria-posinset</a> accordingly; otherwise, this information cannot be computed for context by the user agent.</li>
          <li>A collection of treeitems to be expanded and collapsed are enclosed in a <a class="role-reference" href="#group">group</a>.</li>
          <li>Each tree node which can be expanded should have <a class="property-reference" href="#aria-expanded">aria-expanded</a> set to <code>false</code></li>
          <li>Each tree node which is expanded should have <a class="property-reference" href="#aria-expanded">aria-expanded</a> set to <code>true</code></li>
          <li>Leaf nodes should not have <a class="property-reference" href="#aria-expanded">aria-expanded</a> set</li>
          <li>If <a class="property-reference" href="#aria-multiselectable">aria-multiselectable</a> is set to <code>true</code> on the tree, then each selectable tree node should have <a class="property-reference" href="#aria-selected">aria-selected</a> set to either <code>true</code> or <code>false</code> depending on the current selection.</li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Examples</h4>

          <table aria-label="Treeview examples">
            <thead>
              <tr>
                <th style="min-width: 6em">Example ID</th>
                <th>Action</th>
                <th><code>aria-owns</code></th>
                <th><code>aria-level</code></th>
                <th><code>aria-setsize/<br/><code>aria-posinset</code></th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><a href="examples/treeview/treeview-1a/treeview-1a.html">Treeview 1a</a></td>
                <td>Select a file</td>
                <td class="nu">-</td>
                <td class="computed">Computed</td>
                <td class="computed">Computed</td>
                <td>
                  <ul>
                    <li>Expects browser to compute values for <code>aria-level</code>, <code>aria-posinset</code> and <code>aria-setsize</code> based on DOM structure.</li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><a href="examples/treeview/treeview-1b/treeview-1b.html">Treeview 1b</a></td>
                <td>Select a file</td>
                <td class="nu">-</td>
                <td class="markup">Markup</td>
                <td class="markup">Markup</td>
                <td>
                  <ul>
                    <li>Explicitly defines values of <code>aria-level</code>, <code>aria-posinset</code> and <code>aria-setsize</code></li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><a href="examples/treeview/treeview-2a/treeview-2a.html">Treeview 2a</a></td>
                <td>Follow a link</td>
                <td class="nu">-</td>
                <td class="computed">Computed</td>
                <td class="computed">Computed</td>
                <td>
                  <ul>
                    <li>Expects browser to compute values for <code>aria-level</code>, <code>aria-posinset</code> and <code>aria-setsize</code> based on DOM structure.</li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><a href="examples/treeview/treeview-2b/treeview-2b.html">Treeview 2b</a></td>
                <td>Follow a link</td>
                <td class="nu">-</td>
                <td class="markup">Markup</td>
                <td class="markup">Markup</td>
                <td>
                  <ul>
                    <li>Explicitly defines values of <code>aria-level</code>, <code>aria-posinset</code> and <code>aria-setsize</code></li>
                  </ul>
                </td>
              </tr>
            </tbody>
          </table>


      </section>
    </section>

    <section class="widget" id="windowsplitter">
      <h3>Window Splitter</h3>
      <p>Visible separator between sections of a Window that is used to modify the size of the panes.</p>
      <p>A Window Splitter can take one of two forms -- fixed size and variable size.</p>

      <section class="notoc">
        <h4>Keyboard Interaction</h4>

        <ul>
          <li><kbd>Tab</kbd>: Moves focus   in to and out of the splitter. </li>
          <li><kbd>Left Arrow</kbd> and <kbd>Right Arrow</kbd>: Move a vertical splitter left and right.</li>
          <li><kbd>Up Arrow</kbd> and <kbd>Down Arrow</kbd>: Move a horizontal splitter up and down.</li>
          <li><kbd>Enter</kbd>: If pane controlled by the splitter is not collapsed, then collapse the pane. If the pane is collapsed then restore the splitter to its previous position. </li>
          <li><kbd>End</kbd> (Optional): moves splitter so the associated pane is the largest allowed size. </li>
          <li><kbd>Home</kbd> (Optional): Moves splitter so the associated pane is the smallest allowed size. This may collapse the pane completely. </li>
          <li><kbd>F6</kbd> (Optional): Cycle through the window   panes. </li>
        </ul>

        <p class="note">A fixed size splitter simply omits implementation of the arrow keys. </p>
      </section>

      <section class="notoc">
        <h4>WAI-ARIA Roles, States, and Properties</h4>
        <ul>
          <li>The splitter has role <a href="separator" class="role-reference">separator</a>.</li>
          <li>If the splitter is expandable and collapsible, keep the splitter's <a href="#aria-expanded" class="state-reference">aria-expanded</a> state updated accordingly.</li>
          <li>Label the splitter with <a href="aria-label" class="property-reference">aria-label</a>, <a href="aria-labelledby" class="property-reference">aria-labelledby</a>, or the <code>title</code> attribute. </li>
          <li>Set the <a href="#aria-controls" class="property-reference">aria-controls</a> attribute of the element with role <code>separator</code> role to the IDs of the panes whose sizes it controls. </li>
        </ul>
      </section>

      <section class="notoc">
        <h4>Example</h4>
        <p class="note">Any examples referenced here that are hosted outside www.w3.org may have changed and may not accurately exemplify the guidance in this section. The APG task force is developing examples for APG version 1.1 that will be directly incorporated into the guide.</p>
        <ul>
          <li><a href="http://archive.dojotoolkit.org/nightly/dojotoolkit/dijit/tests/layout/test_BorderContainer.html" target="_blank" rel="nofollow">Dojo Window splitter</a></li>
        </ul>
      </section>
    </section>

  </section>

  <section class="widget" id="aria_landmark">
    <h2>Landmark Roles Design Patterns</h2>

    <p>
      Landmarks provide a powerful way to identify the organization and structure of a web page.
      The structural information conveyed visually to users should be represented programmatically in the markup using landmark roles.
      The use of landmark roles supports keyboard navigation to the structure of a web page for screen reader users, and can be used as targets for author supplied &quot;skip links&quot; and browser extensions for enhanced keyboard navigation.
    </p>

    <p>This section is intended to assist designers, developers and quality assurance staff in defining and understanding the importance of logical, usable, and accessible layout for assistive technologies using HTML5 sectioning elements and ARIA landmark roles.</p>

    <section>
      <h3>HTML5 Sectioning Elements</h3>

      <p>
        It is important to understand that many HTML5 sectioning elements by default define ARIA landmarks. If HTML5 sectioning elements are used without understanding the associated landmark structure, assistive technology users will most likely be confused
        and less efficient in accessing content and interacting with web pages.
        <a href="https://www.w3.org/TR/html-aria/">More information on HTML5 element role mapping</a>.
      </p>

      <table class="widget-features">
        <caption>Default landmark roles for HTML5 sectioning elements</caption>

        <thead>
          <tr>
            <th>HTML5 Element</th>

            <th>Default Landmark Role</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td><code>aside</code></td>

            <td><code>complementary</code></td>
          </tr>

          <tr>
            <td><code>footer</code></td>

            <td><code>contentinfo</code> when in context of the <code>body</code> element</td>
          </tr>

          <tr>
            <td><code>header</code></td>

            <td><code>banner</code> when in context of the <code>body</code> element</td>
          </tr>

          <tr>
            <td><code>main</code></td>

            <td><code>main</code></td>
          </tr>

          <tr>
            <td><code>nav</code></td>

            <td><code>navigation</code></td>
          </tr>

          <tr>
            <td><code>section</code></td>

            <td><code>region</code> when it has an accessible name using <code>aria-labelledby</code> or <code>aria-label</code></td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h3>General Principles of Landmark Design</h3>

      <p>Due to the complexity of todays web content, if using landmarks, <strong>all content</strong> should reside in a semantically meaningful landmark in order that content is not missed by the user.</p>

      <p><strong>Step 1: Identify the logical structure</strong></p>

      <ul>
        <li>Break the page into perceivable areas of content which designers typically indicate visually using alignment and spacing.</li>

        <li>Areas can be further defined into logical sub-areas as needed.</li>

        <li>An example of a sub-area is a portlet in a portal application.</li>
      </ul>

      <p><strong>Step 2: Assign landmark roles to each area</strong></p>

      <ul>
        <li>Assign landmark roles based on the type of content in the area.</li>

        <li><code>banner</code>, <code>main</code>, <code>complementary</code> and <code>contentinfo</code> landmarks should be top level landmarks.</li>

        <li>Landmark roles can be nested to identify parent/child relationships of the information being presented.</li>
      </ul>

      <p><strong>Step 3: Label areas</strong></p>

      <ul>
        <li>If a specific landmark role is used more than once on a web page, it should have a unique label.</li>

        <li>If a landmark is only used once on the page it may not require a label. See Landmark Roles section below. </li>

        <li>If an area begins with a heading element (e.g. <code>h1-h6</code>) it can be used as the label for the area using the <code>aria-labelledby</code> attribute.</li>

        <li>If an area requires a label and does not have a heading element, provide a label using the <code>aria-label</code> attribute.</li>

        <li>
          Do not use the landmark role as part of the label.
          For example, a navigation landmark with a label &quot;Site Navigation&quot; will be announced by a screen reader as &quot;Site Navigation Navigation&quot;.
          The label should simply be &quot;Site&quot;.
        </li>
      </ul>
    </section>

    <section>
      <h3>Landmark Roles</h3>

      <section class="widget" id="aria_lh_banner">
        <h4 class="widget-name">Banner</h4>

        <p>
          A <a href="https://www.w3.org/TR/wai-aria-1.1/#banner"><code>banner</code></a> landmark identifies site-oriented content at the beginning of each page within a website. Site-oriented content typically includes things such as the logo or identity
          of the site sponsor, and site-specific search tool. A banner usually appears at the top of the page and typically spans the full width.
        </p>

        <ul>
          <li>Each page may have one <code>banner</code> landmark.</li>

          <li>The <code>banner</code> landmark should be a top-level landmark.</li>

          <li>When a page contains nested <code>document</code> and/or <code>application</code> roles (e.g. typically through the use of <code>iframe</code> and <code>frame</code> elements), each <code>document</code> or <code>application</code> role may have
            one <code>banner</code> landmark.</li>

          <li>If a page includes more than one <code>banner</code> landmark, each should have a unique label (see Step 3 above).</li>
        </ul>

        <section class="notoc">
          <h5>HTML5 Techniques</h5>
          <ul>
            <li>The HTML5 <code>header</code> element defines a <code>banner</code> landmark when its context is the <code>body</code> element.</li>

            <li>
              The HTML5 <code>header</code> element is not considered a <code>banner</code> landmark when it is descendant of any of following elements (see <a href="http://w3c.github.io/aria/html-aam/html-aam.html">HTML Accessibility Mappings</a>):
              <ul>
                <li><code>article</code></li>
                <li><code>aside</code></li>
                <li><code>main</code></li>
                <li><code>nav</code></li>
                <li><code>section</code></li>
              </ul>
            </li>
          </ul>

          <h5>ARIA Techniques</h5>

          <p>If the HTML5 <code>header</code> element technique is not being used, a <code>role=&quot;banner&quot;</code> attribute should be used to define a <code>banner</code> landmark.</p>
        </section>

        <section class="notoc">
          <h5>Examples</h5>

          <p><a href="examples/landmarks/banner.html">Banner Landmark Example</a></p>
        </section>

      </section>

      <section id="aria_lh_complementary">
        <h4 class="widget-name">Complementary</h4>

        <p>A <a href="https://www.w3.org/TR/wai-aria-1.1/#complementary"><code>complementary</code></a> landmark is a supporting section of the document, designed to be complementary to the main content at a similar level in the DOM hierarchy, but remains meaningful
          when separated from the main content.</p>

        <ul>
          <li><code>complementary</code> landmarks should be top level landmarks (e.g. not contained within any other landmarks).</li>

          <li>If the complementary content is not related to the main content, a more general role should be assigned (e.g. <code>region</code>).</li>

          <li>If a page includes more than one <code>complementary</code> landmark, each should have a unique label (see Step 3 above).</li>
        </ul>

        <section class="notoc">
          <h5>HTML5 Technique</h5>

          <p>Use the HTML5 <code>aside</code> element to define a <code>complementary</code> landmark.</p>

          <h5>ARIA Technique</h5>

          <p>If the HTML5 <code>aside</code> element technique is not being used, use a <code>role=&quot;complementary&quot;</code> attribute to define a <code>complementary</code> landmark.</p>
        </section>

        <section class="notoc">
          <h5>Examples</h5>

          <p><a href="examples/landmarks/complementary.html">Complementary Landmark Example</a></p>
        </section>
      </section>

      <section id="aria_lh_contentinfo">
        <h4 class="widget-name">Contentinfo</h4>

        <p>A <a href="https://www.w3.org/TR/wai-aria-1.1/#contentinfo"><code>contentinfo</code></a> landmark is a way to identify common information at the bottom of each page within a website, typically called the &quot;footer&quot; of the page, including information
          such as copyrights and links to privacy and accessibility statements.</p>

        <ul>
          <li>Each page may have one <code>contentinfo</code> landmark.</li>

          <li>The <code>contentinfo</code> landmark should be a top-level landmark.</li>

          <li>When a page contains nested <code>document</code> and/or <code>application</code> roles (e.g. typically through the use of <code>iframe</code> and <code>frame</code> elements), each <code>document</code> or <code>application</code> role may have
            one <code>contentinfo</code> landmark.</li>

          <li>If a page includes more than one <code>contentinfo</code> landmark, each should have a unique label (see Step 3 above).</li>
        </ul>

        <section class="notoc">

          <h5>HTML5 Techniques</h5>

          <ul>
            <li>The HTML5 <code>footer</code> element defines a <code>contentinfo</code> landmark when its context is the <code>body</code> element.</li>

            <li>
              The HTML5 <code>footer</code> element is not considered a <code>contentinfo</code> landmark when it is descendant of any of following elements (see <a href="http://w3c.github.io/aria/html-aam/html-aam.html">HTML Accessibility Mappings</a>):
              <ul>
                <li><code>article</code></li>
                <li><code>aside</code></li>
                <li><code>main</code></li>
                <li><code>nav</code></li>
                <li><code>section</code></li>
              </ul>
            </li>
          </ul>

          <h5>ARIA Technique</h5>

          <p>If the HTML5 <code>footer</code> element technique is not being used, a <code>role=&quot;contentinfo&quot;</code> attribute should be used to define a <code>contentinfo</code> landmark.</p>
        </section>

        <section class="notoc">
          <h5>Examples</h5>
          <p><a href="examples/landmarks/contentinfo.html">Contentinfo Landmark Example</a></p>
        </section>
      </section>

      <section id="aria_lh_form">
        <h4 class="widget-name">Form</h4>

        <p>A <a href="https://www.w3.org/TR/wai-aria-1.1/#form"><code>form</code></a> landmark identifies a region that contains a collection of items and objects that, as a whole, combine to create a form when no other named landmark is appropriate (e.g. main
          or search).</p>

        <ul>
          <li>Use the <code>search</code> landmark instead of the <code>form</code> landmark when the form is used for search functionality.</li>

          <li>A <code>form</code> landmark should have a label to help users understand the purpose of the form.</li>

          <li>A label for the <code>form</code> landmark should be visible to all users (e.g. an <code>h1-h6</code> element).</li>

          <li>If a page includes more than one <code>form</code> landmark, each should have a unique label (see Step 3 above).</li>

          <li>
            Whenever possible, controls contained in a <code>form</code> landmark in an HTML document should use native host semantics:
            <ul>
              <li><code>button</code></li>

              <li><code>input</code></li>

              <li><code>select</code></li>

              <li><code>textarea</code></li>
            </ul>
          </li>
        </ul>

        <section class="notoc">
          <h5>HTML5 Techniques</h5>

          <p>The HTML5 <code>form</code> element that defines a <code>form</code> landmark when it has an accessible name (e.g. <code>aria-labelledby</code>, <code>aria-label</code> or <code>title</code>).</p>

          <h5>ARIA Technique</h5>

          <p>Use the <code>role=&quot;form&quot;</code> to identify a region of the page; do not use it to identify every form field.</p>
        </section>

        <section class="notoc">
          <h5>Examples</h5>

          <p><a href="examples/landmarks/form.html">Form Landmark Example</a></p>
        </section>
      </section>

      <section id="aria_lh_main">
        <h4 class="widget-name">Main</h4>

        <p>A <a href="https://www.w3.org/TR/wai-aria-1.1/#main"><code>main</code></a> landmark identifies the primary content of the page.</p>

        <ul>
          <li>Each page should have one <code>main</code> landmark.</li>

          <li>The <code>main</code> landmark should be a top-level landmark.</li>

          <li>When a page contains nested <code>document</code> and/or <code>application</code> roles (e.g. typically through the use of <code>iframe</code> and <code>frame</code> elements), each <code>document</code> or <code>application</code> role may have
            one <code>main</code> landmark.</li>

          <li>If a page includes more than one <code>main</code> landmark, each should have a unique label (see Step 3 above).</li>
        </ul>

        <section class="notoc">
          <h5>HTML5 Technique</h5>

          <p>Use the HTML5 <code>main</code> element to define a <code>main</code> landmark.</p>

          <h5>ARIA Technique</h5>

          <p>If the HTML5 <code>main</code> element technique is not being used, use a <code>role=&quot;main&quot;</code> attribute to define a <code>main</code> landmark.</p>
        </section>

        <section class="notoc">
          <h5>Examples</h5>

          <p><a href="examples/landmarks/main.html">Main Landmark Example</a></p>
        </section>
      </section>

      <section id="aria_lh_navigation">
        <h4 class="widget-name">Navigation</h4>

        <p><a href="https://www.w3.org/TR/wai-aria-1.1/#navigation"><code>Navigation</code></a> landmarks provide a way to identify groups (e.g. lists) of links that are intended to be used for website or page content navigation.</p>

        <ul>
          <li>If a page includes more than one <code>navigation</code> landmark, each should have a unique label (see Step 3 above).</li>

          <li>If a <code>navigation</code> landmark has an identical set of links as another <code>navigation</code> landmark on the page, use the same label for each <code>navigation</code> landmark.</li>
        </ul>

        <section class="notoc">
          <h5>HTML5 Technique</h5>

          <p>Use the HTML5 <code>nav</code> element to define a <code>navigation</code> landmark.</p>

          <h5>ARIA Technique</h5>

          <p>If the HTML5 <code>nav</code> element technique is not being used, use a <code>role=&quot;navigation&quot;</code> attribute to define a <code>navigation</code> landmark.</p>

        </section>

        <section class="notoc">
          <h5>Examples</h5>

          <p><a href="examples/landmarks/navigation.html">Navigation Landmark Example</a></p>
        </section>
      </section>

      <section id="aria_lh_region">
        <h4 class="widget-name">Region</h4>

        <p>A <a href="https://www.w3.org/TR/wai-aria-1.1/#region"><code>region</code></a> landmark is a perceivable section of the page containing content that is sufficiently important for users to be able to navigate to the section.</p>

        <ul>
          <li>A <code>region</code> landmark must have a label.</li>

          <li>If a page includes more than one <code>region</code> landmark, each should have a unique label (see Step 3 above).</li>

          <li>The <code>region</code> landmark can be used identify content that named landmarks do not appropriately describe.</li>
        </ul>

        <section class="notoc">
          <h5>HTML5 Technique</h5>

          <p>Use the HTML5 <code>section</code> element to define a <code>region</code> landmark.</p>

          <h5>ARIA Technique</h5>

          <p>If the HTML5 <code>section</code> element technique is not being used, use a <code>role=&quot;region&quot;</code> attribute to define a <code>region</code> landmark.</p>
        </section>

        <section class="notoc">
          <h5>Examples</h5>

          <p><a href="examples/landmarks/region.html">Region Landmark Example</a></p>
        </section>
      </section>

      <section id="aria_lh_search">
        <h4 class="widget-name">Search</h4>

        <p>A <a href="https://www.w3.org/TR/wai-aria-1.1/#search"><code>search</code></a> landmark contains a collection of items and objects that, as a whole, combine to create search functionality.</p>

        <ul>
          <li>Use the <code>search</code> landmark instead of the <code>form</code> landmark when the form is used for search functionality.</li>

          <li>If a page includes more than one <code>search</code> landmark, each should have a unique label (see Step 3 above).</li>
        </ul>

        <section class="notoc">
          <h5>HTML5 Technique</h5>
          <p>There is no HTML5 element that defines a <code>search</code> landmark.</p>

          <h5>ARIA Technique</h5>

          <p>The <code>role=&quot;search&quot;</code> attribute defines a <code>search</code> landmark.</p>
        </section>

        <section class="notoc">
          <h5>Examples</h5>

          <p><a href="examples/landmarks/search.html">Search Landmark Example</a></p>
        </section>
      </section>
    </section>
  </section>

  <section id="keyboard">
    <h2>Developing a Keyboard Interface</h2>

    <p>
      Unlike native HTML form elements, browsers do not provide keyboard support for graphical user interface (GUI) components that are made accessible with ARIA; authors have to provide the keyboard support in their code.
      This section describes the principles and methods for making the functionality of a web page that includes ARIA widgets, such as menus and grids, as well as interactive components, such as toolbars and dialogs, operable with a keyboard.
      Along with the basics of focus management, this section offers guidance toward the objective of providing experiences to people who rely on a keyboard that are as efficient and enjoyable as the experiences available to others.
      It covers:
    </p>

    <ol>
      <li>Understanding fundamental principles of focus movement conventions used in ARIA design patterns.</li>
      <li>Maintaining visible focus, predictable focus movement, and distinguishing between keyboard focus and the selected state.</li>
      <li>Managing movement of keyboard focus between components, e.g., how the focus moves when the <kbd>Tab</kbd> and <kbd>Shift+Tab</kbd> keys are pressed.</li>
      <li>Managing movement of keyboard focus inside components that contain multiple focusable elements, e.g., two different methods for programatically exposing focus inside widgets like radio groups, menus, listboxes, trees, and grids.</li>
      <li>Managing focus for modal and non-modal dialogs.</li>
      <li>Determining when to make disabled interactive elements focusable.</li>
      <li>Assigning and revealing keyboard shortcuts, including guidance on how to avoid problematic conflicts with keyboard commands of assistive technologies, browsers, and operating systems.</li>
      <li>Addressing macro navigation concerns, i.e., methods for enabling efficient keyboard access to different sections of a page or site.</li>
    </ol>

    <section id="kbd_generalnav">
      <h3>Fundamental Keyboard Navigation Conventions</h3>

      <p>
        ARIA roles, states, and properties model accessibility behaviors and features shared among GUI components of popular desktop GUIs, including Microsoft Windows, Mac OS X, and GNOME.
        Similarly, ARIA design patterns borrow user expectations and keyboard conventions from those platforms, consistently incorporating common conventions with the aim of facilitating easy learning and efficient operation of keyboard interfaces across the web.
      </p>

      <p>
        For a web page to be accessible, all interactive elements must be operable via the keyboard.
        In addition, consistent application of the common GUI keyboard interface conventions described in the <a href="#aria_ex">ARIA design patterns</a> is important, especially for assistive technology users.
        Consider, for example, a screen reader user operating a tree.
        Just as familiar visual styling helps users discover how to expand a tree branch with a mouse, ARIA attributes give the tree the sound and feel of a tree in a desktop application.
        So, screen reader users will commonly expect that pressing the right arrow key will expand a collapsed node.
        Because the screen reader knows the element is a tree, it also has the ability to instruct a novice user how to operate it.
        Similarly, voice recognition software can implement commands for expanding and collapsing branches because it recognizes the element as a tree and can execute appropriate keyboard commands.
        All this is only possible if the tree implements the GUI keyboard conventions as described in the <a href="#TreeView">ARIA tree pattern</a>.
      </p>

      <p>
        A primary keyboard navigation convention common across all platforms is that the <kbdd>tab</kbdd> and <kbd>shift+tab</kbd> keys move focus from one UI component to another while other keys, primarily the arrow keys, move focus inside of components that include multiple focusable elements.
        The path that the focus follows when pressing the <kbd>tab</kbd> key is known as the tab sequence or tab ring.
      </p>

      <p>
        Common examples of UI components that contain multiple focusable elements are radio groups, tablists, menus, and grids.
        A radio group, for example, contains multiple radio buttons, each of which is focusable.
        However, only one of the radio buttons is included in the tab sequence.
        After pressing the <kbd>Tab</kbd> key moves focus to a radio button in the group, pressing arrow keys moves focus among the radio buttons in the group, and pressing the <kbd>Tab</kbd> key moves focus out of the radio group to the next element in the tab sequence.
      </p>

      <p>
        The ARIA specification refers to a discrete UI component that contains multiple
        focusable elements as a <a href="#composite" class="role-reference">composite</a>
        widget. The process of controlling focus movement inside a composite is called
        managing focus. Following are some ARIA design patterns with example implementations
        that demonstrate focus management:
      </p>

      <ul>
        <li><a href="#combobox">Combobox</a></li>
        <li><a href="#grid">Grid</a></li>
        <li><a href="Listbox">Listbox</a></li>
        <li><a href="#menu">Menu or menu bar</a></li>
        <li><a href="#radiobutton">Radiogroup</a></li>
        <li><a href="#tabpanel">Tabs</a></li>
        <li><a href="#toolbar">Toolbar</a></li>
        <li><a href="#treegrid">Tree Grid</a></li>
        <li><a href="#TreeView">Tree View</a></li>
      </ul>
    </section>

    <section id="kbd_focus_discernable_predictable">
      <h3>Discernable and Predictable Keyboard Focus</h3>

      <p>
        When operating with a keyboard, two essentials of a good experience are the abilities to easily discern the location of the keyboard focus and to discover where focus landed after a navigation key has been pressed.
        The following factors affect to what extent a web page affords users these capabilities.
      </p>

      <ol>
        <li>Visibility of the focus indicator: Users need to be able to easily distinguish the keyboard focus indicator from other features of the visual design. Just as a mouse user may move the mouse to help find the mouse pointer, a keyboard user may press a navigation key to watch for movement. If visual changes in response to focus movement are subtle, many users will lose track of focus and be unable to operate. Authors are advised to rely on the default focus indicators provided by browsers. If overriding the default, consider:
          <ul>
            <li>something about ... Colors and gradients can disappear in high contrast modes.</li>
            <li>Users need to be able to easily distinguish between focus and selection as described in <a href="#kbd_focus_vs_selection"></a>, especially when a component that contains selected elements does not contain the focus.</li>
            <li>... other considerations to be added ...</li>
          </ul>
        </li>

        <li>
          Persistence of focus: It is essential that there is always a component within the user interface that is active (document.activeElement is not null or is not the body element) and that the active element has a visual focus indicator.
          Authors need to manage events that effect the currently active element so focus remains visible and moves logically.
          For example, if the user closes a dialog or performs a destructive operation like deleting an item from a list, the active element may be hidden or removed from the DOM.
          If such events are not managed to set focus on the button that triggered the dialog or on the list item following the deleted item, browsers move focus to the body element, affectively causing a loss of focus within the user interface.
        </li>

        <li>
          Predictability of movement: Usability of a keyboard interface is heavily influenced by how readily users can guess where focus will land after a navigation key is pressed.
          Some possible approaches to optimizing predictability include:

          <ul>
            <li>
              Move focus in a pattern that matches the reading order of the page's language. In left to right languages, for example, create a tab sequence that moves focus left to right and then top to bottom.
            </li>

            <li>
              Incorporate all elements of a section of the page in the tab sequence before moving focus to another section. For instance, in a page
              with multiple columns that has content in a left side bar, center region, and right side bar, build a tab sequence that covers all elements in the left sidebar before focus moves to the first focusable element in the center column.
            </li>

            <li>
              When the distance between two consecutive elements in the tab sequence is significant, avoid movement that would be perceived as backward.
              For example, on a page with a left to right language, a jump from the last element in the bottom right of the main content to the top element in a left-hand sidebar is likely to be less predictable and more difficult to follow, especially for users with a narrow field of view.
            </li>

            <li>
              Follow consistent patterns across a site.
              The keyboard experience is more predictable when similar pages have similar focus movement patterns.
            </li>

            <li>Do not set initial focus when the page loads except in cases where:
              <ul>
                <li>The page offers a single, primary function that nearly all users employ immediately after page load.</li>
                <li>Any given user is likely to use the page often.</li>
              </ul>
            </li>
          </ul>
        </li>
      </ol>
    </section>

    <section id="kbd_focus_vs_selection">
      <h3>Focus VS Selection and the Perception of Dual Focus</h3>

      <p>
        Occasionally, it may appear as if two elements on the page have focus at the same time.
        For example, in a multi-select list box, when an option is selected it may be greyed.
        Yet, the focus indicator can still be moved to other options, which may also be selected.
        Similarly, when a user activates a tab in a tablist, the selected state is set on the tab and its visual appearance changes.
        However, the user can still navigate, moving the focus indicator elsewhere on the page while the tab retains its selected appearance and state.
      </p>

      <p>
        Focus and selection are quite different.
        From the keyboard user's perspective, focus is a pointer, like a mouse pointer; it tracks the path of navigation.
        There is only one point of focus at any time and all operations take place at the point of focus.
        On the other hand, selection is an operation that can be performed in some widgets, such as list boxes, trees, and tablists.
        If a widget supports only single selection, then only one item can be selected and very often the selected state will simply follow the focus when focus is moved inside of the widget.
        That is, in some widgets, moving focus may also perform the select operation.
        However, if the widget supports multiple selection, then more than one item can be in a selected state, and keys for moving focus do not perform selection.
        Some multi-select widgets do support key commands that both move focus and change selection, but those keys are different from the normal navigation keys.
        Finally, when focus leaves a widget that includes a selected element, the selected state persists.
      </p>

      <p>
        From the developer's perspective, the difference is simple -- the focused element is the active element (document.activeElement).
        Selected elements are elements that have <code>aria-selected="true"</code>.
      </p>

      <p>With respect to focus and the selected state, the most important considerations for designers and developers are:</p>

      <ul>
        <li>The visual focus indicator must always be visible.</li>
        <li>The selected state must be visually distinct from the the focus indicator.</li>
      </ul>
    </section>

    <section id="kbd_general_between">
      <h3>Keyboard Navigation Between Components (The Tab Sequence)</h3>

      <p>
        As explained in section <a href="#kbd_generalnav"></a>, all interactive UI components need to be reachable vai the keyboard.
        This is best achieved by either including them in the tab sequence or by making them accessible from a component that is in the tab sequence, e.g., as part of a composite component.
        This section addresses building and managing the tab sequence, and subsequent sections cover making focusable elements that are contained within components keyboard accessible.
      </p>

      <p>
        The <a href="https://www.w3.org/TR/html5/editing.html#attr-tabindex">HTML tabindex</a> and <a href="https://www.w3.org/TR/SVG2/struct.html#tabindexattribute">SVG tabindex</a> attributes can be used to add and remove elements from the tab sequence.
        The value of tabindex can also influence the order of the tab sequence, although authors are strongly advised not to use tabindex for that purpose.
      </p>

      <p>
        In HTML, the default tab sequence of a web page includes only links and HTML form elements, except In Mac OS, where it includes only form elements.
        Mac OS system preferences include a keyboard setting that enables the tab key to move focus to all focusable elements.
      </p>

      <p>
        The default order of elements in the tab sequence is the order of elements in the DOM.
        The DOM order also determines screen reader reading order.
        It is important to keep the keyboard tab sequence and the screen reader reading order aligned, logical, and predictable as described in <a href="#kbd_focus_discernable_predictable"></a>.
        The most robust method of manipulating the order of the tab sequence while also maintaining alignment with the reading order that is currently available in all browsers is rearranging elements in the DOM.
      </p>

      <p>The values of the tabindex attribute have the following effects.</p>

      <dl>
        <dt>tabindex is not present or does not have a valid value</dt>
        <dd>
          The element has its default focus behavior.
          In HTML, only form controls and anchors with an HREF attribute are included in the tab sequence.
        </dd>
        <dt>tabindex="0"</dt>
        <dd>The element is included in the tab sequence based on its position in the DOM.</dd>
        <dt>tabindex="-1"</dt>
        <dd>The element is not included in the tab sequence but is focusable with element.focus().</dd>
        <dt>tabindex="X" where X is an integer in the range 1 &lt;= X &lt;= 32767</dt>
        <dd>
          Authors are strongly advised NOT to use these values.
          The element is placed in the tab sequence based on the value of tabindex.
          Elements with a tabindex value of 0 and elements that are focusable by default will be in the sequence after elements with a tabindex value of 1 or greater.
        </dd>
      </dl>
    </section>

    <section id="kbd_general_within">
      <h3> Keyboard Navigation Inside Components</h3>

      <p>
        As described in section <a href="#kbd_generalnav"></a>, the tab sequence should include only one focusable element of a composite UI component.
        Once a composite contains focus, keys other than <kbd>Tab</kbd> and <kbe>Shift+Tab</kbe> enable the user to move focus among its focusable elements.
        Authors are free to choose which keys move focus inside of a composite, but they are strongly advised to use the same key bindings as similar components in common GUI operating systems as demonstrated in <a href="#aria_ex"></a>.
      </p>

      <p>
        The convention for where focus lands in a composite when it recieves focus as a result of a <kbd>Tab</kbd> key event depends on the type of composite.
        It is typically one of the following.
      </p>

      <ul>
        <li>
          The element that had focus the last time the composite contained focus.
          Or, if the composite has not yet contained the focus, the first element.
          Widgets that usually employ this pattern include grid and tree grid.
        </li>

        <li>
          The selected element. Or, if there is no selected element, the first element.
          Widgets where this pattern is commonly implemented include radio groups, tabs, list boxes, and trees.
          Note: For radio groups, this pattern is referring to the checked radio button; the selected state is not supported for radio buttons.
        </li>

        <li>
          The first element.
          Components that typically follow this pattern include menubars and toolbars.
        </li>
      </ul>

      <p>
        The following sections explain two strategies for managing focus inside composite elements: creating a roving tabindex and using the aria-activedescendant property.
      </p>

      <section id="kbd_roving_tabindex">
        <h4>Managing Focus Within Components Using a Roving tabindex</h4>

        <p>
          When using roving tabindex to manage focus in a composite UI component, the element that is to be included in the tab sequence has tabindex of "0" and all other focusable elements contained in the composite have tabindex of "-1".
          The algorithm for the roving tabindex strategy is as follows.
        </p>

        <ul>
          <li>When the component container is loaded or created, set <code>tabindex="0"</code> on the element that will initially be included in the tab sequence and set <code>tabindex="-1"</code> on all other focusable elements it contains.</li>
          <li>
            When the component contains focus and the user presses a navigation key that moves focus within the component, such as an arrow key:

            <ul>
              <li>set <code>tabindex="-1"</code> on the element that has <code>tabindex="0"</code>.</li>
              <li>Set <code>tabindex="0"</code> on the element that will become focused as a result of the key event.</li>
              <li>Set focus, <code>element.focus()</code>, on the element that has <code>tabindex="0"</code>.</li>
            </ul>
          </li>

          <li>
            If the design calls for a specific element to be focused the next time the user moves focus into the composite with <kbd>Tab<kbd> or <kbd>Shift+Tab</kbd>, check if that target element has <code>tabindex="0"</code> when the composite loses focus.
            If it does not, set <code>tabindex="0"</code> on the target element and set <code>tabindex="-1"</code> on the element that previously had <code>tabindex="0"</code>.
          </li>
        </ul>

        <p>
          One benefit of using roving tabindex rather than aria-activedescendant to manage focus is that the user agent will scroll the newly focused element into view.
        </p>
      </section>

      <section id="kbd_focus_activedescendant">
        <h4>Managing Focus in Composites Using aria-activedescendant</h4>

        <p>
          If a component container has an ARIA role that supports the <a class="property-reference" href="#aria-activedescendant">aria-activedescendant</a> property, it is not necessary to manipulate the tabindex attribute and move DOM focus among focusable elements within the container.
          Instead, only the container element needs to be included in the tab sequence. When the container has DOM focus, the value of aria-activedescendant on the container tells assistive technologies which element is active within the widget.
          Assistive technologies will consider the element referred to as active to be the focused element even though DOM focus is on the element that has the aria-activedescendant property.
          And, when the value of aria-activedescendant is changed, assistive technologies will receive focus change events equivalent to those received when DOM focus actually moves.
        </p>

        <p>The steps for using the aria-activedescendant method of managing focus are as follows.</p>

        <ul>
          <li>
            When the container element that has a role that supports aria-activedescendant is loaded or created, ensure that:

            <ul>
              <li>The container element is included in the tab sequence as described in <a href="#kbd_general_between"></a> or it is otherwise focusable as described in <a href="#kbd_nested_components"></a>.</li>
              <li>
                It has <code>aria-activedescendant="IDREF"</code> where IDREF is the ID of the element within the container that should be identified as active when the widget receives focus.
                The referenced element needs to meet the DOM relationship requirements described below.
              </li>
            </ul>
          </li>

          <li>
            When the container element receives DOM focus, draw a visual focus indicator on the active element and ensure the active element is scrolled into view.
            See section <a href="#scrollintoview">Managing Focus with Scroll</a> below for more information.
          </li>

          <li>
            When the composite widget contains focus and the user presses a navigation key that moves focus within the widget, such as an arrow key:

            <ul>
              <li>Change the value of aria-activedescendant on the container to refer to the element that should be reported to assistive technologies as active.</li>
              <li>Move the visual focus indicator and, if necessary,  scrolled the active element into view.</li>
            </ul>
          </li>

          <li>
            If the design calls for a specific element to be focused the next time a user moves focus into the composite with <kbd>Tab</kbd> or <kbd>Shift+Tab</kbd>, check if aria-activedescendant is referring to that target element when the container loses focus.
            If it is not, set aria-activedescendant to refer to the target element.
          </li>
        </ul>

        <p>
          The <a href="#aria-activedescendant" class="property-reference">specification for aria-activedescendant</a> places important restrictions on the DOM relationship between the focused element that has the aria-activedescendant attribute and the element referenced as active by the value of the attribute.
          One of the following three conditions must be met.
        </p>

        <ol>
          <li>The element referenced as active is a DOM descendant of the focused referencing element.</li>

          <li>The focused referencing element has a value specified for the <a href="#aria-owns" class="property-reference">aria-owns</a> property that includes the ID of the element referenced as active.</li>

          <li>
            The focused referencing element has role of <a href="#textbox" class="role-reference">textbox</a> and has <a href="#aria-controls" class="property-reference">aria-controls</a> property referring to an element with a role that supports aria-activedescendant and either:

            <ol>
              <li>The element referenced as active is a descendant of the controlled element.</li>
              <li>The controlled element has a value specified for the <a href="#aria-owns" class="property-reference">aria-owns</a> property that includes the ID of the element referenced as active.</li>
            </ol>
          </li>
        </ol>
      </section>

      <section id="kbd_nested_components">
        <h4>Nested Composite Components - Composites and Toolbars That Contain Composites</h4>

        <p>to be written</p>
      </section>

      <section id="scrollintoview">
        <h5>Managing Focus with Scroll</h5>

        <p class="note">Not yet edited ... considering what should be written/included. We don't want to write a javascript book.</p>

        <p>
          In some browsers, a JavaScript call to <code> scrollIntoView()</code> on this element should suffice, but in browsers where   this is unreliable, authors should explicitly set the <code>scrollTop</code> and <code>scrollLeft</code> properties of the "cell23" element and its ancestors to scroll the element into view. <code>scrollTop</code> and <code>scrollLeft</code> adjust the node positions by the amounts(pixels) needed to scroll a node into view.
          Scrolling values are adjusted by the amounts(pixels) needed to scroll a node into view.
          This is done by comparing the sizes of the nodes using available measurements such as scroll+offset+clientWidth/Height/Left/Top. It's important to note that you have to adjust a node so that it's viewable within
          the context of its parent node.
          Then you have to move up the DOM tree and make
          each parent node visible.
        </p>

        <p>
          For example, create a custom <code> scrollIntoView()</code> method that is called at various times, including coincidence with the setting of the <a class="property-reference" href="#aria-activedescendant">aria-activedescendant</a> property.
          The method takes a DOM node argument, say "n". Here is the high level algorithm:
        </p>

        <ol>
          <li> If n is already in view, stop; otherwise, continue. </li>
          <li> adjust n.scrollTop and n.scrollLeft such that it is in view. </li>
          <li>adjust scrollTop and scrollLeft for the ancestor nodes of n such that   that the region of the ancestors which n consumes is visible.</li>
        </ol>

        <p>This is a minimum-position-change algorithm.</p>

        <p>
          Understanding how the DOM scrollIntoView works across browsers is important.
          Browsers (including Firefox3) force the node either to the top or the bottom of the screen (as defined by the single Boolean parameter) even if its already in view.
          This is problematic when you only need to scroll horizontally to see the element.
          It is also problematic when the node is partially off the bottom of the screen and the parameter is (true) which forces the node all the way to the top, and vice versa with the top going to the bottom on (false).
          IE forces the node to the left of the client area (or right in right-to-left mode) even if it's horizontally in view already.
        </p>

        <p>
          The <code>scrollTop</code> and<code> scrollLeft</code> functions create some challenges.
          <code>scrollTop</code> is always accurate but misleading with respect to inner (nested) scrollbars.
          <code> scrollLeft</code> cannot be relied on in right-to-left languages because it is sometimes negative and sometimes positive especially with respect to inner (nested) scrollbars.
          Different browsers handle right-to-left completely differently.
        </p>
      </section>
    </section>

    <section id="modal_dialog">
      <h3>Managing Focus in Dialogs</h3>

      <p class="note">
        MCK: unedited content pulled together from the old guide that needs a significant re-write.
        Please ignore this section for now.
      </p>

      <p>
        WAI-ARIA provides for two dialog roles - dialog and alertdialog. When authors simulate dialogs on a web page they often limit their interaction considerations to the mouse.
        Unlike Graphical User Interface dialog boxes on a desktop computer, a user during keyboard navigation could accidentally navigate outside the dialog box and become disoriented.
        This can happen when the user is tabbing in the dialog.
        A modal dialog prevents the user from setting focus outside of the dialog until the dialog is closed.
        Mouse clicks outside of the dialog must be ignored and the user must not be able to tab into or out of the dialog itself.
        All WAI-ARIA enabled dialog boxes should be modal.
        This section describes how.
      </p>

      <p>
        Mouse clicks outside of the dialog can be prevented by creating a CSS positioned element that is the size of the viewport to append as a child of the body element.
        Set the CSS z-index of this element so that it is above all other elements on the page except for the dialog element.
        Set the tabindex of the underlay element to tabindex="-1" to prevent it from receiving focus via a keyboard event or mouse click.
        You may lower the opacity of the underlay element in order to emphasize that the dialog itself is modal and has focus.
      </p>

      <p>
        Depending upon the action to be performed by the dialog, the object with focus before the dialog box is opened should be saved.
        This will allow restoring focus to this element when the dialog box is closed.
        When the dialog box is opened, focus should be set to the first tab focusable element within the dialog.
        If there is no tab focusable element within the dialog box contents, set the focus to the item that is used to cancel or close the dialog.
        There must be some element within the dialog which can accept focus in order for the screen reader to speak the dialog title and information when it is opened.
        In order to prevent keyboard focus from leaving the dialog, determine the first and last tab focusable elements in the dialog and trap keyboard events within the document.
      </p>

      <p>
        Search the contents of the dialog container to find the first and last tab focusable elements.
        This can be implemented by walking the DOM tree of the dialog container to find all visible and enabled anchor elements, input elements, and all elements that have a tabindex value greater than or equal to 0.
        Remember that elements with a tabindex > 0 will appear in the tab order before all other focusable elements in ascending order by tabindex.
        Store the first and last tab focusable items within variables in the scope of the dialog box code.
      </p>

      <p>
        Before the dialog is shown, create and display the dialog underlay.
        Connect an onkeypress event handler to the DOM document.documentElement.
        This will catch all keystrokes on the document and allow trapping keyboard focus within the dialog.
        Size and position the dialog box in the viewport above the underlay, make it visible and set focus to the first tab focusable item in the dialog box.
      </p>

      <p>
        The onkeypress handler will catch all key presses within the document.
        This onkeypress event handler should be within the scope of the dialog box code so that it has access to the first and last tab focusable elements within the dialog.
        In the onkeypress handler determine the target of the keypress event.
        In addition, determine if there is only a single focusable item within the dialog box.
        In this instance the first tab navigable object will equal the last tab navigable object.
        If key presses within the dialog box may create, destroy, enable, disable, or change the visibility of tab focusable elements, then determine the first and last tab-focusable items each time a keypress is received.
        Based on the event target and the key pressed take the following actions:
      </p>

      <ul>
        <li>
          If the keypress is a <kbd>Shift + Tab</kbd> key and the target == the first tab navigable object, then set focus to the last tab-navigable object and stop the key press event. If there is only a single tab focusable item, then focus does not have to be set, but the key press event must be stopped.
        </li>
        <li>
          If the keypress is a <kbd>Tab</kbd> key and the target == the last tab navigable object, then set focus to the first tab-navigable object and stop the keypress event. If there is only a single tab-focusable item, then focus does not have to be set but the keypress event must must be stopped.
        </li>
        <li>
          If the keypress is an <kbd>Escape</kbd> key and the target node is the container node for the dialog box, then close the dialog box and hide or destroy the dialog underlay.
        </li>
      </ul>

      <p>
        Determine if the target node of the keypress is within the dialog box container. This can be done using a while loop to walk the parent chain of the target node until the container node of the dialog box is found. Other than those outlined above, all key presses from within the dialog box should be allowed to execute so that the user can interact with the controls in the dialog box.
      </p>

      <p>
        If the target node is not within the dialog box, the keypress is from the documentElement and the keypress event should be stopped unless it is a <kbd>Tab</kbd> key press. Allowing a <kbd>Tab</kbd> key press from the document element will enable tabbing back into the dialog box if, for some reason, focus on the dialog box is lost. This can happen due to timing issues when the dialog box is first loaded and focus does not properly get set to the first tab-focusable item within the dialog.
      </p>

      <p>
        The dialog box itself should contain buttons or other mechanisms to cancel the dialog box or execute the dialog box functions and close the dialog box.
      </p>

      <p>
        Here is a pseudo code onkeypress handler for a modal dialog box. Pseudo code is used to focus on the actions in the handler rather than on the differences in browser event handling. Assume that the event object, evt, has been normalized between browsers and the helper object is a library of functions that handle browser differences. The keys object is a set of key definition variables. Dialog is the dialog box object, which has a function to cancel the dialog.
      </p>

<pre>
_onKey: function(/*Normalized Event*/ evt){
// summary:
// Handles the keyboard events for accessibility reasons
if(evt.charOrCode){
var node = evt.target; // get the target node of the keypress event
if (evt.charOrCode === keys.TAB){
// find the first and last tab focusable items in the hierarchy of the dialog container node
// do this every time if the items may be added / removed from the the dialog may change visibility or state
var focusItemsArray = helper.getFocusItems(dialogContainerNode);
dialog.firstFocusItem = focusItemsArray[0];
dialog.lastFocusItem = focusItemsArray[focusItemsArray.length-1];
}
// assumes firstFocusItem and lastFocusItem maintained by dialog object
var singleFocusItem = (dialog.firstFocusItem == dialog.lastFocusItem);

// see if we are shift-tabbing from first focusable item on dialog
if(node == dialog.firstFocusItem &amp;&amp; evt.shiftKey &amp;&amp; evt.charOrCode === keys.TAB){
if(!singleFocusItem){
dialog.lastFocusItem.focus(); // send focus to last item in dialog
}
helper.stopEvent(evt); //stop the tab keypress event
}
// see if we are tabbing from the last focusable item
else if(node == dialog.lastFocusItem &amp;&amp; evt.charOrCode === keys.TAB &amp;&amp; !evt.shiftKey){
if (!singleFocusItem){
dialog.firstFocusItem).focus(); // send focus to first item in dialog
}
helper.stopEvent(evt); //stop the tab keypress event
}
else{
// see if the key is for the dialog
while(node){
if(node == dialogContainerNode){ // if this is the container node of the dialog
if(evt.charOrCode == keys.ESCAPE){ // and the escape key was pressed
dialog.cancel(); // cancel the dialog
}else{
return; // just let it go
}
}
node = node.parentNode;
}
// this key is for the document window
if(evt.charOrCode !== keys.TAB){ // allow tabbing into the dialog
helper.stopEvent(evt); //stop the event if not a tab keypress
}
} // end of if evt.charOrCode
} // end of function
</pre>
    </section>

    <section id="kbd_disabled_controls">
      <h3>Focusability of disabled controls</h3>

      <p>
        By default, disabled HTML input elements are removed from the tab sequence.
        In most contexts, the normal expectation is that disabled interactive elements are not focusable.
        However, there are some contexts where it is common for disabled elements to be focusable, especially inside of composite widgets.
        For example, as demonstrated in the <a href="#menu"></a> pattern, disabled items are focusable when navigating through a menu with the arrow keys.
      </p>

      <p>
        Removing focusability from disabled elements can offer users both advantages and disadvantages.
        Allowing keyboard users to skip disabled elements usually reduces the number of key presses required to complete a task.
        However, preventing focus from moving to disabled elements can hide their presence from screen reader users who "see" by moving the focus.
      </p>

      <p>
        Authors are encouraged to adopt a consistent set of conventions for the focusability of disabled elements.
        The examples in this guide adopt the following conventions, which both reflect common practice and attempt to balance competing concerns.
      </p>

      <ol>
        <li>For elements that are in the tab sequence when enabled, remove them from the tab sequence when disabled.</li>

        <li>
          For the following composite widget elements, keep them focusable when disabled:

          <ul>
            <li>Options in a <a href="Listbox">Listbox</a></li>
            <li>Menu items in a <a href="#menu">Menu or menu bar</a></li>
            <li>Tab elements in a set of <a href="#tabpanel">Tabs</a></li>
            <li>Tree items in a <a href="#TreeView">Tree View</a></li>
          </ul>
        </li>

        <li>
          For elements contained in a toolbar, make them focusable if discoverability is a concern. Here are two examples to aid with this judgment.

          <ol>
            <li>
              A toolbar with buttons for moving, removing, and adding items in a list includes buttons for &quot;Up&quot;, &quot;Down&quot;, &quot;Add&quot;, and &quot;Remove&quot;.
              The &quot;Up&quot; button is disabled and its focusability is removed when the first item in the list is selected.
              Given the  presence of the &quot;Down&quot; button, discoverability of the &quot;Up&quot; button is not a concern.
            </li>

            <li>
              A toolbar in an editor contains a set of special smart paste functions that are disabled when the clipboard is empty or when the function is not applicable to the current content of the clipboard.
              It could be helpful to keep the disabled buttons focusable if the ability to discover their functionality is primarily via their presence on the toolbar.
            </li>
          </ol>
        </li>
      </ol>

      <p>One design technique for mitigating the impact of including disabled elements in the path of keyboard focus is employing appropriate keyboard shortcuts as described in <a href="#kbd_shortcuts"></a>.</p>
    </section>

    <section id="kbd_shortcuts">
      <h3>Keyboard Shortcuts</h3>

      <p>
        When effectively designed, keyboard shortcuts that focus an element, activate a widget, or both can dramatically enhance usability of frequently used features of a page or site.
        This section addresses some of the keyboard shortcut design and implementation factors that most impact their effectiveness, including:
      </p>

      <ol>
        <li>Understanding how keyboard shortcuts augment a keyboard interface and whether to make a particular shortcut move focus, perform a function, or both. </li>
        <li>Making key assignments and avoiding assignment conflicts with assistive technologies, browsers, and operating systems. </li>
        <li>Exposing and documenting key assignments. </li>
      </ol>

      <section id="kbd_shortcuts_behavior_design">
        <h4>Designing the Scope and Behavior of Keyboard Shortcuts</h4>

        <p>This section explains the following factors when determining which elements and features to assign keyboard shortcuts and what behavior to give each shortcut:</p>

        <ol>
          <li>Ensuring discovery through navigation; keyboard shortcuts enhance, not replace, standard keyboard access.</li>

          <li>
            Effectively choosing from among the following behaviors:

            <ol>
              <li>Navigation: Moving focus to an element. </li>
              <li>Activation: Performing an operation associated with an element that does not have focus and might not be visible.</li>
              <li>Navigation and activation: Both moving focus to an element and activating it.</li>
            </ol>
          </li>

          <li>Balancing efficiency and cognitive load: lack of a shortcut can reduce efficiency while too many shortcuts can increase cognitive load and clutter the experience.</li>
        </ol>

        <section id="kbd_shortcuts_design_basic">
          <h5>Ensure Basic Access Via Navigation </h5>

          <p>
            Before assigning keyboard shortcuts, it is essential to ensure the features and functions to which shortcuts may be assigned are keyboard accessible without a keyboard shortcut.
            In other words, all elements that could be targets for keyboard shortcuts need to be focusable via the keyboard using the methods described in:
          </p>

          <ul>
            <li><a href="#kbd_general_between"></a> </li>
            <li><a href="#kbd_general_within"></a> </li>
          </ul>

          <p>
            Do not use keyboard shortcuts as a substitute for access via navigation.
            This is essential to full keyboard access because:
          </p>

          <ol>
            <li>The primary means of making functions and their shortcuts discoverable is by making the target elements focusable and revealing key assignments on the element itself.</li>
            <li>If people who rely on the keyboard have to read documentation to learn which keys are required to use an interface, the interface may technically meet some accessibility standards but in practice is only accessible to the small subset of them who have the knowledge that such documentation exists, have the extra time available, and the ability to retain the necessary information.</li>
            <li>Not all devices that depend on keyboard interfaces can support keyboard shortcuts.</li>
          </ol>
        </section>

        <section id="kbd_shortcuts_design_choose_behavior">
          <h5>Choose Appropriate Shortcut Behavior</h5>

          <p>The following conventions may help identify the most advantageous behavior for a keyboard shortcut.</p>

          <ul>
            <li>
              Move focus when the primary objective is to make navigation more efficient, e.g., reduce the number of times the user must press <kbd>Tab</kbd> or the arrow keys.
              This behavior is commonly expected when assigning a shortcut to a text box, toolbar, or composite, such as a listbox, tree, grid, or menubar.
              This behavior is also useful for moving focus to a section of a page, such as the main content or a complementary landmark section.
            </li>

            <li>
              Activate an element without moving focus when the target context of the funtion is the context that contains the focus.
              This behavior is most common for command buttons and for functions associated with elements that are not visible, such as a "Save" option that is accessible via a menu.
              For example, if the focus is on an option in a listbox and a toolbar contains buttons for moving and removing options, it is most benefitial to keep focus in the listbox when the user presses a key shortcut for one of the buttons in the toolbar.
              This behavior can be particularly important for screen reader users because it provides confirmation of the action performed and makes performing multiple commands more efficient.
              For instance, when a screen reader user presses the shortcut for the "Up" button, the user will be able to hear the new position of the option in the list since it still has the focus.
              Similarly, when the user presses the shortcut for deleting an option, the user can hear the next option in the list and immediately decide whether to press the delete shortcut again.
            </li>

            <li>
              Move focus and activate when the target of the shortcut has a single function and the context of that function is the same as the target.
              This behavior is typical when a shortcut is assigned to a button that opens a menu or dialog, to a checkbox, or to a navigation link or button.
            </li>
          </ul>
        </section>

        <section id="kbd_shortcuts_design_where">
          <h5>Choose Where to Add Shortcuts </h5>

          <p>
            The first goal when designing a keyboard interface is simple, efficient, and and intuitive operation with only basic keyboard navigation support.
            If basic operation of a keyboard interface is inefficient , attempting to compensate for fundamental design issues, such as suboptimal layout or command structure,  by implementing keyboard shortcuts will not likely reduce user frustration.
            The practical implication of this is that, in most well-designed user interfaces, the percentage of functionality that needs to be accessible via a keyboard shortcut in order to create optimal usability is not very high.
            In many simple user interfaces, keyboard shortcuts can be entirely superfluous.
            And, in user interfaces with too many keyboard shortcuts, the excess shortcuts create cognitive load that make the most useful ones more difficult to remember.
          </p>

          <p>Consider the following when deciding where to assign keyboard shortcuts: </p>

          <ol>
            <li>To be written ... stream of consciousness includes frequency of use, repetitive operations, amount of benefit (key presses saved), minimizing the number with placement, e.g., focus on a menubar with first letter nav vs assigning shortcuts to individual menuitems.</li>
          </ol>
        </section>
      </section>

      <section id="kbd_shortcuts_assigning">
        <h4>Assigning Keyboard Shortcuts</h4>

        <p>When choosing the keys to assign to a shortcut, there are many factors to consider.</p>

        <ul>
          <li>Making the shortcut easy to learn and remember by using a mnemonic (e.g., "S" for "Save") or following a logical or spacial pattern.</li>
          <li> Localizing the interface, including for differences in which keys are available and how they behave and for language considerations that could impact mnemonics. </li>
          <li>Avoiding and managing conflicts with key assignments used by an assistive technology, the browser, or the operating system.</li>
        </ul>

        <p>
          Methods for designing a key shortcut scheme that supports learning and memory is beyond the scope of this guide.
          Unless the key shortcut scheme is extensive, it is likely sufficient to mimic concepts that are familiar from common desktop software, such as browsers.
          Similarly, while localization is important, describing how to address it is left to other resources that specialize in that topic.
        </p>

        <p>
          The remainder of this section provides guidance balancing requirements and concerns related to key assignment conflicts.
          It is typically ideal if key assignments do not conflict with keys that are assigned to functions in the user's operating system, browser, or assistive technology.
          Conflicts can block efficient access to functions that are essential to the user, and a perfect storm of conflicts can trap a user.
          At the same time, there are some circumstances where intentional conflicts are useful.
          And, given the vast array of operating system, browser, and assistive technology keys, it is almost impossible to be certain conflicts do not exist.
          So it is also important to employ strategies that mitigate the impact of conflicts whether they are intentional or unknown.
        </p>

        <p class="note">
          In the following sections, <kbd>meta</kbd> key refers to the <kbd>Windows</kbd> key on Windows-compatible keyboards and the <kbd>Command</kbd> key on MacOS-compatible keyboards.
        </p>

        <section id="kbd_shortcuts_assignments_opsys_conflicts">
          <h5>Operating System Key Conflicts</h5>

          <p>
            It is essential to avoid conflicts with keys that perform system level functions, such as appplication and window management and display and sound control.
            In general, this can be achieved by refraining from the following types of assignments.
          </p>

          <ol>
            <li>Any modifier keys + any of <kbd>Tab</kbd>, <kbd>Enter</kbd>, <kbd>Space</kbd>, or <kbd>Escape</kbd>.</li>

            <li><kbd>Meta</kbd> key + any other single key (there are exceptions, but they can be risky as these keys can change across versions of operating systems). </li>

            <li><kbd>Alt</kbd> + a function key.</li>
          </ol>

          <p>
            In addition, there are some important application level features that most applications, including browsers, generally support.
            These include:
          </p>

          <ol>
            <li>Zoom</li>
            <li>Copy/Paste</li>
            <li> ... to be continued ... </li>
          </ol>
        </section>

        <section id="kbd_shortcuts_assignments_assistivetech_conflicts">
          <h5>Assistive Technology Key Connflicts</h5>

          <p>
            Even though assistive technologies have collectively taken thousands of key assignments, avoiding conflicts is relatively easy.
            This is because assistive technologies have had to develop key assignment schemes that avoid conflicts with both operating systems and applications.
            They do this by hijacking specific keys as modifiers that uniquely define their key commands.
            For example, many assistive technologies use the <kbd>Caps Lock</kbd> key as a modifier.
          </p>

          <p>Deflect assistive technology key conflicts by steering clear of the following types of assignments. </p>

          <ol>
            <li><kbd>Caps Lock</kbd> + any other combination of keys.</li>
            <li><kbd>Insert</kbd> + any combination of other keys.</li>
            <li><kbd>Scroll Lock</kbd> + any combination of other keys.</li>
            <li>Mac OS only: <kbd>Control+Option</kbd> + any combination of other keys.</li>
          </ol>
        </section>

        <section id="kbd_shortcuts_assignments_browser_conflicts">
          <h5>Browser Key Connflicts</h5>

          <p>
            While there is considerable similarity among browser keyboard schemes, the patterns within the schemes are less homogenious.
            Consequently, it is more difficult to avoid conflicts with browser key assignments.
            While the impact of conflicts is sometimes mitigated by the availability of two paths to nearly every function -- keyboard accessible menus and keyboard shortcuts, avoiding conflicts with shortcuts to heavily used functions is nonetheless important.
            Pay special attention to avoiding conflicts with shortcuts to:
          </p>

          <ol>
            <li>Address or location bar</li>
            <li>Notification bar</li>
            <li>Page refresh</li>
            <li>Bookmark and history functions</li>
            <li>Find functions</li>
          </ol>
        </section>

        <section id="kbd_shortcuts_assignments_mitigating_conflicts">
          <h5>Mitigating Key Connflict Likelihood and Impact</h5>
        </section>

        <section id="kbd_shortcuts_assignments_intentional_conflicts">
          <h5>Intentional Key Conflicts</h5>

          <p>
            While avoiding key conflicts is usually desirable, there are circumstances where intentionally conflicting with a browser function is acceptable or even desirable.
            This can occur when the following combination of conditions arises:
          </p>

          <ul>
            <li>A web application has a frequently used function that is similar to a browser function.</li>
            <li>Users will often want to execute the web application function.</li>
            <li>Users will rarely execute the browser function.</li>
            <li>There is an efficient, alternative path to the browser function.</li>
          </ul>

          <p>For example, consider a save function that is available when the focus is in an editor. Most browsers use ... to be continued ...</p>
        </section>
      </section>

      <section id="kbd_shortcuts_exposing">
        <h4>Exposing and Documenting Keyboard Shortcuts</h4>
        <p>
          This is where we will talk about how the keyshortcuts property exposes shortcuts to assistive technology, visual exposure via tooltips, and the like.
          We will also cover making it easy to find documentation, such as in an accessibility section in help or a keyboard shortcuts option in a help menu.
        </p>
      </section>

      <section id="kbd_shortcuts_implementing">
        <h4>Implementing keyboard shortcuts</h4>
        <p>
          Not sure if we will have this section ... could include some js tips and note about access keys ... <a href="http://www.w3.org/TR/1999/REC-html401-19991224/interact/forms.html#h-17.11.2">accesskey</a> behave differently in different browsers.
        </p>
      </section>
    </section>

    <section id="keyboard_js_tips">
      <H3>Other Keyboard Interface Development Tips</H3>

      <p class="note">MCK: this section is a collection of keyboard related old content with a yet undecided fate.</p>

      <section id="kbd_misc">
        <h4>Miscelaneous stuff we might or might not keep</h4>

        <ul>
          <li>
            <em>Use focus and blur events (or event delegation) to monitor changes to the current focus</em> - <code>focus</code> and <code>blur</code> events can now be used with every element.
            Don't assume that all focus changes will come via key and mouse events, because assistive technologies such as screen readers can set the focus to any focusable element, and that needs to be handled elegantly by the JavaScript widget.
            Techniques such as &quot;event delegation&quot; (for example, intercepting events on a list rather than on every listitem) can improve performance.
          </li>

          <li>
            <em>Follow keydowns to move focus</em> - A keydown event handler can determine the next object to receive focus and call that element's focus() method.
          </li>

          <li>
            <em>Use onkeydown to trap key events, not onkeypress</em> - Key press events do not fire for all keys and they vary across browsers.
          </li>

          <li>
            <em>Use element.focus() to set focus</em> - Do not use createEvent(), initEvent() and dispatchEvent() to send focus to an element, because these functions do not change the focus.  DOM focus events are informational only, generated by the user agent after an element has acquired focus, but not used themselves to set focus.
          </li>

          <li>
            The use of :focus pseudo-class selectors to style the keyboard focus is not supported in many versions of Internet Explorer. Authors should use the :active pseudo-class (which older versions of IE treat like :focus) in conjunction with the :focus pseudo-class. Example: a:focus, a:active { text-decoration: underline; }
            If the related CSS pseudo-classes are not appropriate or not supported in all browsers, authors can use JavaScript techniques to indicate an appropriate focus alternative, such as using focus and blur events to toggle a classname on an element.
          </li>

          <li>
            <em>Always draw the focus for tabindex="-1" items and elements that receive focus programmatically when supporting versions of Internet Explorer older than 8</em> - Choose between changing the background  color via something like this.style.backgroundColor = "gray"; or add a dotted border via this.style.border = "1px dotted invert".  In the dotted border case, you will need to make sure those elements  have an invisible 1px border to start with, so that the element doesn't  grow when the border style is applied (borders take up space, and IE  doesn't implement CSS outlines).
          </li>

          <li>
            <p><em>Prevent used key events from performing browser functions</em> - If a key such as an arrow key is used, prevent the browser from using the key to do something (such as scrolling) by using code like the following:</p>
            <pre class="example highlight">&lt;span tabindex=&quot;-1&quot; onkeypress=&quot;return  handleKeyPress();&quot;&gt; </pre>
            <p>
              If handleKeyDown() returns false, the event will be consumed, preventing the browser from performing any action based on the keystroke.
              In addition to the return value the browser must call the event methods that will prevent the default action, for IE this is setting the event property &quot;returnValue=false&quot;, and for other browsers supporting the W3C event model this means calling the &quot;preventDefault&quot; method of the event object.
            </p>
          </li>

          <li>
            <em>Use key event handlers to enable activation of the element</em> - For every mouse event handler, a keyboard event handler is required.
            For example, if you have an <em>onclick="doSomething()"</em> you may also need <em>onkeydown="return event.keyCode != 13 || doSomething();" </em>in order to allow the <kbd>Enter</kbd> key to activate that element.
            There are <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets" target="_blank">user agent-specific considerations</a> for key event handling.
          </li>
        </ul>

      </section>

      <section id="kbd_tooltips">
        <h3> Supporting Tooltips with the Keyboard</h3>

        <p>
          A <a class="role-reference" href="#tooltip">tooltip</a> is a  popup messages typically triggered by moving a mouse over a control or widget causing a small popup window to appear with additional information about the control.
          To provide simple text tooltips, the <a href="http://www.w3.org/TR/1999/REC-html401-19991224/struct/global.html#h-7.4.3">HTML title attribute</a> should more than suffice because the user agent will render it for tooltips.
          When creating a <a class="role-reference" href="#tooltip">tooltip</a>, it is essential that  the user be able to activate it using the keyboard.
          When a form control or widget receives keyboard focus, the <a class="role-reference" href="#tooltip">tooltip</a> must display.
          When the form control or widget loses focus, the tooltip must disappear.
          Browsers do not currently support this functionality.
        </p>

        <p>The following code snippet from the <a href="http://oaa-accessibility.org/examplep/tooltip1/"><abbr title="Illinois Center for Information Technology Accessibility">iCITA</abbr></a> site shows the use of a <span class="example highlight">onfocus=&quot;tooltipShow();&quot;</span> function to display the tooltip when focus is placed on an element.</p>

        <pre class="example higlight" id="line1">&lt;html lang="en-us""&gt;
&lt;head&gt;
   &lt;title&gt;inline: Tooltip Example 1&lt;/title&gt;
   &lt;link rel="stylesheet" href="css/tooltip1_inline.css"  type="text/css"&gt;
   &lt;script type="text/javascript" src="js/tooltip1_inline.js"&gt;&lt;/script&gt;
   &lt;script type="text/javascript" src="../js/widgets_inline.js"&gt;&lt;/script&gt;
   &lt;script type="text/javascript" src="../js/globals.js"&gt;&lt;/script&gt;
   &lt;link rel="icon" href="http://www.cites.uiuc.edu/favicon.ico" type="image/x-icon"&gt;
   &lt;link rel="shortcut icon" href="http://www.cites.uiuc.edu/favicon.ico" type="image/x-icon"&gt;
&lt;/head&gt;
   &#8230;

   &lt;body onload="initApp()"&gt;

   &lt;div id="container"&gt;

   &lt;h1&gt;Tooltip Example 1&lt;/h1&gt;
     &lt;h2&gt;Create Account&lt;/h2&gt;
   &lt;div class="text"&gt;
   &lt;label for="first"&gt;First Name:&lt;/label&gt;

   &lt;input type="text"  id="first" name="first" size="20"
          onmouseover="tooltipShow(event, this, 'tp1');"
          onfocus=&quot;tooltipShow(event, this,  'tp1');&quot;
          aria-describedby="tp1"
          aria-required="false"/&gt;

   &lt;div id="tp1" role="tooltip" aria-hidden="true"&gt;Your first name is optional. &lt;/div&gt;
   &lt;/div&gt;
  &#8230;
        </pre>
      </section>
    </section>
  </section>

  <section id="gridAndTableProperties">
    <h2>Grid and Table Properties</h2>

    <p>
      [placeholder].
      This section will cover colcount, rowcount, colindex, rowindex, colspan, rowspan, and sort.
      It will explain when they are useful and how to use them.
      It is referenced by the grid and table design patterns.
      This section will refer readers to the grid and table design patterns for the basics of grid and table.
    </p>
  </section>

  <section id="appendices" class="appendix">
    <h2>Appendices</h2>

    <section id="ScreenReaderModes">
      <h3>Understanding Screen Reader Document Reading and Application Reading Modes</h3>
      <p>Placeholder for a section covering this topic that is yet to be written.</p>
    </section>

    <section class="appendix" id="ariaBackground">
      <h3>Background on WAI-ARIA</h3>
      <p>[Placeholder section that will be resolved by <a href="https://github.com/w3c/aria-practices/issues/84">issue #84</a>.]</p>
    </section>

    <div data-include='common/acknowledgements.html' data-include-replace='true'></div>
  </section>
</body>
</html>
